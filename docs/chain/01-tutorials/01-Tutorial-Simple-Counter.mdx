---
id: docs-chain-tutorials-simple-counter
title: Simple Counter App
hide_title: false
slug: ./tutorial-simple-counter
displayed_sidebar: pushChainSidebar
sidebar_position: 1
image: '/assets/docs/previews/notifications--intro_to_push_notification.png'
---

<head>
  <title>Simple Counter | Tutorials | Push Chain Docs</title>
</head>

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {
  ModalContainer,
  ModalSmall,
  ModalWrapper,
} from '@site/src/css/SharedStyling';
import IFrameModal from '@site/src/components/IFrameModal/IFrameModal';

<!-- Content Start -->

Welcome to the first tutorial of building and deploying smart contracts on Push Chain.

We will start with the most popular smart contract, i.e., `Counter.sol`, that all Solidity devs are familiar with.

The tutorial is designed to achieve the following:

1. Start with basic building and deployment of a Counter contract.
2. Modify the Counter contract to a UniversalCounter that works with multiple chains.
3. Deeply understand the uniqueness and benefits of building Universal Apps on Push Chain.

## Let’s Build Counter

The process of building a simple smart contract like a counter is exactly similar to any other EVM Chain.

You can use the same tools, such as:

- [Solidity Language](https://soliditylang.org/)
- [Foundry](https://getfoundry.sh/), or [Hardhat](https://hardhat.org/)
- [Remix IDE](https://remix.ethereum.org/)

To get started, you can use the following contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

contract Counter {
    uint256 public countPC;
    event CountIncremented(uint256 indexed countPC, address indexed caller);

    function increment() public {
        countPC += 1;
        emit CountIncremented(countPC, msg.sender);
    }

    function reset() public {
        countPC = 0;
    }
}
```

The contract is a simple counter contract that:

- Allows the caller to increment the variable `countPC`.
- Emits an event with the current value of `countPC` and the caller’s address.
- Allows anyone to reset the `countPC` to zero.

## Build and Deploy the Contract

You can use any of the following guides to build and deploy this contract on Push Chain:

1. [Remix IDE](https://remix.ethereum.org/)
2. [Foundry Configuration](/docs/chain/setup/smart-contract-environment/configure-foundry/)
3. [Hardhat Configuration](/docs/chain/setup/smart-contract-environment/configure-hardhat/)

Once deployed, you can interact with the Counter contract just like on any other EVM-compatible chain.

## Let's Test our SimpleCounter

```jsx live
import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import {
  PushUniversalWalletProvider,
  PushUniversalAccountButton,
  usePushWalletContext,
  usePushChainClient,
  PushUI,
} from '@pushchain/ui-kit';

function SimpleCounterExample() {
  // Define Wallet Config
  const walletConfig = {
    network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET,
  };

  // Define Simple Counter ABI, taking minimal ABI for the demo
  const UCABI = [
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: 'uint256',
          name: 'countPC',
          type: 'uint256',
        },
        {
          indexed: true,
          internalType: 'address',
          name: 'caller',
          type: 'address',
        },
      ],
      name: 'CountIncremented',
      type: 'event',
    },
    {
      inputs: [],
      name: 'increment',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'reset',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'countPC',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
  ];

  // Contract address for the Simple Counter
  const CONTRACT_ADDRESS = '0x959ED7f6943bdd56B3a359BAE0115fef4aa07e17';

  function Component() {
    const { connectionStatus } = usePushWalletContext();
    const { pushChainClient } = usePushChainClient();

    // State to store counter values
    const [countPC, setCountPC] = useState(-1);
    const [isLoadingIncrement, setIsLoadingIncrement] = useState(false);
    const [isLoadingReset, setIsLoadingReset] = useState(false);
    const [txHash, setTxHash] = useState('');

    // Function to encode increment transaction data
    const getIncrementTxData = () => {
      return PushChain.utils.helpers.encodeTxData({
        abi: UCABI,
        functionName: 'increment',
      });
    };

    // Function to encode reset transaction data
    const getResetTxData = () => {
      return PushChain.utils.helpers.encodeTxData({
        abi: UCABI,
        functionName: 'reset',
      });
    };

    // Function to fetch counter values
    const fetchCounters = async () => {
      if (!pushChainClient) return;

      try {
        const provider = new ethers.JsonRpcProvider(
          'https://evm.rpc-testnet-donut-node1.push.org/'
        );
        const contract = new ethers.Contract(CONTRACT_ADDRESS, UCABI, provider);

        const pcCount = await contract.countPC();
        setCountPC(Number(pcCount));
      } catch (err) {
        console.error('Error fetching counter values:', err);
      }
    };

    // Fetch counter values on component mount and when connection status changes
    useEffect(() => {
      if (connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED) {
        fetchCounters();
      }
    }, [connectionStatus, pushChainClient]);

    // Handle transaction to increment counter
    const handleSendTransaction = async () => {
      if (pushChainClient) {
        try {
          setIsLoadingIncrement(true);
          const data = getIncrementTxData();

          const tx = await pushChainClient.universal.sendTransaction({
            to: CONTRACT_ADDRESS,
            value: BigInt(0),
            data: data,
          });

          setTxHash(tx.hash);
          await tx.wait();

          await fetchCounters();
          setIsLoadingIncrement(false);
        } catch (err) {
          console.error('Transaction error:', err);
          setIsLoadingIncrement(false);
        }
      }
    };

    // Handle transaction to reset counter
    const handleResetTransaction = async () => {
      if (pushChainClient) {
        try {
          setIsLoadingReset(true);
          const data = getResetTxData();

          const tx = await pushChainClient.universal.sendTransaction({
            to: CONTRACT_ADDRESS,
            value: BigInt(0),
            data: data,
          });

          setTxHash(tx.hash);
          await tx.wait();

          await fetchCounters();
          setIsLoadingReset(false);
        } catch (err) {
          console.error('Reset transaction error:', err);
          setIsLoadingReset(false);
        }
      }
    };

    return (
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '12px',
        }}
      >
        <h2>Simple Counter Example</h2>

        <PushUniversalAccountButton />

        {connectionStatus !== PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED && (
          <p>Please connect your wallet to interact with the counter.</p>
        )}

        <div
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '12px',
            width: '100%',
            flexWrap: 'nowrap',
          }}
        >
          <h3>PC Counter: {countPC == -1 ? '...' : countPC}</h3>
        </div>

        {connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED && (
          <div className='counter-container' style={{ display: 'grid' }}>
            <button
              className='increment-button'
              onClick={handleSendTransaction}
              disabled={isLoadingIncrement}
            >
              {isLoadingIncrement ? 'Processing...' : 'Increment Counter'}
            </button>

            <button
              className='reset-button'
              onClick={handleResetTransaction}
              disabled={isLoadingReset}
            >
              {isLoadingReset ? 'Processing...' : 'Reset Counter'}
            </button>

            {txHash && pushChainClient && (
              <div className='transaction-info' style={{ display: 'grid' }}>
                <p>
                  Transaction Hash: <code>{txHash}</code>
                </p>
                <a
                  href={pushChainClient.explorer.getTransactionUrl(txHash)}
                  target='_blank'
                >
                  View in Explorer
                </a>
                <button onClick={fetchCounters} className='refresh-button'>
                  Refresh Counter Values
                </button>
              </div>
            )}
          </div>
        )}
      </div>
    );
  }

  return (
    <PushUniversalWalletProvider config={walletConfig}>
      <Component />
    </PushUniversalWalletProvider>
  );
}
```

## What's Next?

While this was a simple tutorial to help you get started with deploying contracts on Push Chain, the next phase introduces the power of **Universal Apps**.

In the next part, we modify this contract to implement the following:

1. `increment()` can be called by users on **any chain**.
2. The contract will natively detect which chain the `msg.sender` belongs to.
3. The contract will maintain a `count` for each chain based on the caller’s origin.

> All of these features will be natively supported in the contract with no requirement of
> third-party oracles, interop providers or packages.
>
> **This is only possible on Push Chain.**

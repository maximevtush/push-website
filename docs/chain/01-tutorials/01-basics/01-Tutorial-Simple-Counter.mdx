---
id: docs-chain-tutorials-simple-counter
title: Build a Counter App
hide_title: false
slug: ./tutorial-simple-counter
displayed_sidebar: pushChainSidebar
sidebar_position: 1
image: "/assets/docs/previews/docs_chain_tutorials_simple_counter--build_a_counter_app.png"
---

<head>
  <title>Build a Counter App | Tutorials | Push Chain Docs</title>
</head>

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {
  ModalContainer,
  ModalSmall,
  ModalWrapper,
} from '@site/src/css/SharedStyling';
import IFrameModal from '@site/src/components/IFrameModal/IFrameModal';
import TutorialTimer from '@site/src/components/TutorialTimer';
import { GitHubRepo } from '@site/src/components/GitHubRepo';

<!-- Content Start -->

<TutorialTimer estimatedMinutes={10} />

In this tutorial, youâ€™ll write, deploy, and interact with a simple Counter contract on Push Chain. 

We will start with the most popular smart contract, i.e., `Counter.sol`, that all Solidity devs are familiar with. You would have done the following by the end:

- âœ… Build and deploy Counter.sol
- âœ… Interact with it from any chain
- âœ… Understand the benefits of building Universal Apps
- âœ… Use **Live Playground** to test and interact with SimpleCounter
- ðŸ”œ Extend to a Universal Counter that tracks chain specific users

## Write the Contract
The process of building a simple smart contract like a counter is exactly similar to any other EVM Chain.
You can use the same tools, such as, remix, foundry, hardhat, etc.

To get started, you can use the following contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

contract Counter {
    uint256 public countPC;
    event CountIncremented(uint256 indexed countPC, address indexed caller);

    function increment() public {
        countPC += 1;
        emit CountIncremented(countPC, msg.sender);
    }

    function reset() public {
        countPC = 0;
    }
}
```

The contract is a simple counter contract that:

- Allows the caller to increment the variable `countPC`.
- Emits an event with the current value of `countPC` and the callerâ€™s address.
- Allows anyone to reset the `countPC` to zero.

## Compile & Deploy

You can use any of the following guides to build and deploy this contract on Push Chain:

1. [Remix IDE](https://remix.ethereum.org/)
2. [Foundry Configuration](/docs/chain/setup/smart-contract-environment/configure-foundry/)
3. [Hardhat Configuration](/docs/chain/setup/smart-contract-environment/configure-hardhat/)

Once deployed, you can interact with the Counter contract just like on any other EVM-compatible chain.

## Verify Contract

If you are using Foundry or Hardhat, the contract is already verified for you. If you are using Remix, you can verify the contract on the Push Chain Explorer by going to [verify and publish contract](https://donut.push.network/contract-verification).

## Interact with SimpleCounter App
An easier way to interact with the contract is to use the LivePlayground below.
The SimpleCounter app is already deployed on Push Chain Testnet.
> **SimpleCounter Contract Address:** [0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266](https://donut.push.network/address/0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266?tab=contract)

**Note:** Push Chain easily allows you to interact with the SimpleCounter from any chain.

Follow the steps below to interact with the SimpleCounter:
- Connect your wallet to the LivePlayground.
- You can connect wallet of any supported chain ( Push Chain, Ethereum or Solana)
- Click on the `Increment Counter` button to increment the counter.
- Click on the `Refresh Counter Values` button to refresh the counter values.
- After each transaction, click the hash link to view it on Push Chain Explorer.

## Live Playground

```jsx live
import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import {
  PushUniversalWalletProvider,
  PushUniversalAccountButton,
  usePushWalletContext,
  usePushChainClient,
  PushUI,
} from '@pushchain/ui-kit';

function SimpleCounterExample() {
  // Define Wallet Config
  const walletConfig = {
    network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET,
  };

  // Define Simple Counter ABI, taking minimal ABI for the demo
  const UCABI = [
    {
      inputs: [],
      name: 'increment',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'countPC',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
  ];

  // Contract address for Simple Counter
  const CONTRACT_ADDRESS = '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266';

  function Component() {
    const { connectionStatus } = usePushWalletContext();
    const { pushChainClient } = usePushChainClient();

    // State to store counter values
    const [countPC, setCountPC] = useState(-1);
    const [isLoadingIncrement, setIsLoadingIncrement] = useState(false);
    const [isLoadingReset, setIsLoadingReset] = useState(false);
    const [txHash, setTxHash] = useState('');

    // Function to encode increment transaction data
    const getIncrementTxData = () => {
      return PushChain.utils.helpers.encodeTxData({
        abi: UCABI,
        functionName: 'increment',
      });
    };

    // Function to fetch counter values
    const fetchCounters = async () => {
      if (!pushChainClient) return;

      try {
        const provider = new ethers.JsonRpcProvider(
          'https://evm.rpc-testnet-donut-node1.push.org/'
        );
        const contract = new ethers.Contract(CONTRACT_ADDRESS, UCABI, provider);

        const pcCount = await contract.countPC();
        setCountPC(Number(pcCount));
      } catch (err) {
        console.error('Error fetching counter values:', err);
      }
    };

    // Fetch counter values on component mount and when connection status changes
    useEffect(() => {
      if (connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED) {
        fetchCounters();
      }
    }, [connectionStatus, pushChainClient]);

    // Handle transaction to increment counter
    const handleSendTransaction = async () => {
      if (pushChainClient) {
        try {
          setIsLoadingIncrement(true);
          const data = getIncrementTxData();

          const tx = await pushChainClient.universal.sendTransaction({
            to: CONTRACT_ADDRESS,
            value: BigInt(0),
            data: data,
          });

          setTxHash(tx.hash);
          await tx.wait();

          await fetchCounters();
          setIsLoadingIncrement(false);
        } catch (err) {
          console.error('Transaction error:', err);
          setIsLoadingIncrement(false);
        }
      }
    };

    return (
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '12px',
        }}
      >
        <h2>Simple Counter Example</h2>

        <PushUniversalAccountButton />

        {connectionStatus !== PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED && (
          <p>Please connect your wallet to interact with the counter.</p>
        )}

        <div
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '12px',
            width: '100%',
            flexWrap: 'nowrap',
          }}
        >
          <h3>Counter: {countPC == -1 ? '...' : countPC}</h3>
        </div>

        {connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED && (
          <div className='counter-container' style={{ display: 'flex', flexDirection: 'column', gap: '16px', alignItems: 'center' }}>
            <div style={{ display: 'flex', justifyContent: 'center', gap: '20px' }}>
              <button
                className='increment-button'
                onClick={handleSendTransaction}
                disabled={isLoadingIncrement}
                style={{
                  backgroundColor: '#d946ef',
                  color: 'white',
                  border: 'none',
                  borderRadius: '20px',
                  padding: '8px 16px',
                  fontSize: '14px',
                  cursor: 'pointer',
                  fontWeight: 'bold'
                }}
              >
                {isLoadingIncrement ? 'Processing...' : 'Increment Counter'}
              </button>
            </div>

            {txHash && pushChainClient && (
              <div className='transaction-info' style={{ textAlign: 'center' }}>
                <p>
                  Transaction Hash:{' '}
                  <a
                    href={pushChainClient.explorer.getTransactionUrl(txHash)}
                    target='_blank'
                    style={{ color: '#d946ef', textDecoration: 'underline' }}
                  >
                    {txHash}
                  </a>
                </p>
              </div>
            )}
          </div>
        )}
      </div>
    );
  }

  return (
    <PushUniversalWalletProvider config={walletConfig}>
      <Component />
    </PushUniversalWalletProvider>
  );
}
```
## Source Code
<GitHubRepo 
  title="Simple Counter Tutorial"
  repoUrl="https://github.com/pushchain/push-chain-examples/tree/main/tutorials/simple-counter"
  description="Full source code for the Universal Simple Counter smart contract and example frontend."
/>

## What we Achieved

This was just a simple tutorial. What we did in this tutorial:

- Deployed a simple counter contract on Push Chain.
- Interacted seamlessly with the contract from any chain. (Ethereum, Solana or Push Chain)


## Next Tutorial

The next tutorial introduces the true power of **Universal Apps**.

<div style={{textAlign: 'center'}}>

```mermaid
flowchart TD
    EU[Ethereum User] --> UC[Universal Counter Contract]
    SU[Solana User] --> UC
    PU[Push Chain User] --> UC
    
    UC --> EC[Ethereum Counter: 5]
    UC --> SC[Solana Counter: 3] 
    UC --> PC[Push Chain Counter: 8]
    
    style UC fill:#dd44b9,stroke:#fff,stroke-width:2px,color:#fff
    style EC fill:#627eea,stroke:#fff,stroke-width:2px,color:#fff
    style SC fill:#9945ff,stroke:#fff,stroke-width:2px,color:#fff
    style PC fill:#dd44b9,stroke:#fff,stroke-width:2px,color:#fff
    style EU fill:#627eea,color:#fff
    style SU fill:#9945ff,color:#fff
    style PU fill:#dd44b9,color:#fff
```

</div>

<hr />

In the next part, we modify this contract to implement the following:

1. `increment()` called by users of **any chain** will now be attributed to them.
2. The contract will natively detect which chain the `msg.sender` belongs to.
3. The contract will maintain a `count` for each chain based on the callerâ€™s origin.

> All of these features will be natively supported in the contract with no requirement of
> third-party oracles, interop providers or packages.
> **This is only possible on Push Chain.**

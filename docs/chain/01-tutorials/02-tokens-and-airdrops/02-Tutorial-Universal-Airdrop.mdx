---
id: docs-chain-tutorials-universal-airdrop
title: 'Build a Claimable Universal Airdrop'
hide_title: false
slug: ./tutorial-universal-airdrop
displayed_sidebar: pushChainSidebar
sidebar_position: 6
image: '/assets/docs/previews/docs_chain_tutorials_universal_airdrop--build_a_universal_airdrop:_proofs,_contract,_and_claim_ui.png'
---

<head>
  <title>{`Build a Universal Airdrop: Generate Merkle Proofs, Deploy Contract, and Add a Claim UI | Tutorials | Push Chain Docs`}</title>
</head>

{/* Content Start */}

Welcome! In this tutorial, you'll build a **Universal Airdrop** system that revolutionizes cross-chain token distribution. Unlike traditional airdrops that require deploying contracts on every blockchain, this universal approach lets you **deploy once on Push Chain** and enable users from **any blockchain** (Ethereum, Solana, Polygon, etc.) to claim their tokens seamlessly.

## Why Universal Airdrops?

The beauty of this system lies in its efficiency and cross-chain compatibility:

- **Single Deployment**: Deploy your airdrop contract once on Push Chain instead of managing multiple contracts across different networks
- **Cross-Chain Claims**: Users from Ethereum, Solana, Polygon, and other chains can all claim tokens from the same contract
- **No Multi-Chain Token Deployment**: Keep your ERC-20 token on one chain while enabling universal claiming
- **User Simplicity**: Recipients can claim their tokens using their preferred wallet on their own chain, making the process seamless and familiar

We‚Äôll build the complete flow:

1. Generate Merkle proofs with cross-chain recipient data
2. Deploy a universal Merkle claim contract to Push Chain
3. Create a UI for recipients to claim their tokens from any chain

## Part 1: Generate the Merkle proofs

In this part, we'll create a Merkle proof generator that produces cryptographic proofs for a universal airdrop system. This generator will create a Merkle tree from recipient data and generate proofs that can be verified on-chain.

### 1.1. Set up the Merkle proof generator

Create the project directory and install the required dependencies:

```bash
mkdir merkle-proof-generator
cd merkle-proof-generator
npm init -y
tsc --init
npm install bs58 merkletreejs viem
npm i -D @types/node
```

The dependencies you'll need:

- `merkletreejs`: Core library for building Merkle trees with cryptographic hashing
- `viem`: Ethereum library providing `keccak256` hashing and ABI encoding utilities
- `bs58`: Base58 encoding/decoding library for Solana addresses

#### Create the main generator script

Create `merkle-proof-generator/index.ts` with the following implementation:

```typescript
import { keccak256, encodeAbiParameters } from 'viem';
import { MerkleTree } from 'merkletreejs';
import * as fs from 'fs';
import * as path from 'path';
import bs58 from 'bs58';

interface AirdropEntry {
  recipient: string;
  chainNamespace: 'eip155' | 'solana' | 'push' | string;
  chainId: string;
  amount: string;
}

interface TreeEntry extends AirdropEntry {
  leaf: `0x${string}`;
  proof: `0x${string}`[];
}

interface TreeData {
  merkleRoot: `0x${string}`;
  entries: TreeEntry[];
}

/**
 * Generate a leaf hash matching the Solidity contract
 * leaf = keccak256(abi.encodePacked(recipientOnPush, chainNamespace, chainId, amount))
 */
function generateLeaf(entry: AirdropEntry): `0x${string}` {
  const { recipient, chainNamespace, chainId, amount } = entry;

  // Normalize recipient address:
  // - If hex 0x address (length 42), parse as 20-byte address
  // - Else treat as base58 (e.g., Solana), hash bytes and take last 20 bytes
  let recipientAddressHex: string;
  if (recipient.startsWith('0x')) {
    const addr = recipient.toLowerCase();
    const addressBytes = addr.slice(2).padStart(40, '0');
    recipientAddressHex = addressBytes;
  } else {
    const raw = Buffer.from(bs58.decode(recipient));
    const hashed = Buffer.from(
      keccak256(`0x${raw.toString('hex')}`).slice(2),
      'hex'
    );
    const last20 = hashed.slice(-20);
    recipientAddressHex = last20.toString('hex');
  }

  const namespaceBytes = Buffer.from(chainNamespace, 'utf8');
  const chainIdBytes = Buffer.from(chainId, 'utf8');
  const amountBytes = Buffer.alloc(32);
  amountBytes.writeBigUInt64BE(BigInt(amount), 24);

  const packedBytes = Buffer.concat([
    Buffer.from(recipientAddressHex, 'hex'),
    namespaceBytes,
    chainIdBytes,
    amountBytes,
  ]);

  return keccak256(`0x${packedBytes.toString('hex')}`);
}

/**
 * Build Merkle tree from airdrop entries
 */
function buildMerkleTree(entries: AirdropEntry[]): TreeData {
  // Generate leaves
  const leaves = entries.map((entry) => generateLeaf(entry));

  // Create Merkle tree with sorted pairs
  const tree = new MerkleTree(leaves, keccak256, { sortPairs: true });
  const merkleRoot = tree.getHexRoot() as `0x${string}`;

  // Generate proofs for each entry
  const entriesWithProofs: TreeEntry[] = entries.map((entry, index) => {
    const leaf = leaves[index];
    const proof = tree.getHexProof(leaf) as `0x${string}`[];

    return {
      ...entry,
      leaf,
      proof,
    };
  });

  return {
    merkleRoot,
    entries: entriesWithProofs,
  };
}

/**
 * Print summary of the airdrop data
 */
function printSummary(treeData: TreeData): void {
  const { entries, merkleRoot } = treeData;

  console.log('üå≥ Universal Airdrop Merkle Tree Summary');
  console.log('=====================================');
  console.log(`üìÅ Merkle Root: ${merkleRoot}`);
  console.log(`üë• Total Recipients: ${entries.length}`);

  // Calculate totals per chain namespace
  const chainStats = entries.reduce(
    (acc, entry) => {
      const key = `${entry.chainNamespace}:${entry.chainId}`;
      if (!acc[key]) {
        acc[key] = { count: 0, totalAmount: BigInt(0) };
      }
      acc[key].count += 1;
      acc[key].totalAmount += BigInt(entry.amount);
      return acc;
    },
    {} as Record<string, { count: number; totalAmount: bigint }>
  );

  console.log('\nüìä Per-Chain Breakdown:');
  Object.entries(chainStats).forEach(([chain, stats]) => {
    console.log(
      `  ${chain}: ${stats.count} recipients, ${stats.totalAmount.toString()} tokens`
    );
  });

  // Calculate total amount
  const totalAmount = entries.reduce(
    (sum, entry) => sum + BigInt(entry.amount),
    BigInt(0)
  );
  console.log(`\nüí∞ Total Airdrop Amount: ${totalAmount.toString()} tokens`);
}

// Main execution
async function main() {
  const airdropPath = path.join(__dirname, './data/airdrop.json');

  // Check if airdrop file exists
  if (!fs.existsSync(airdropPath)) {
    console.error('‚ùå Airdrop file not found at:', airdropPath);
    console.log('\nPlease create data/airdrop.json with the following format:');
    console.log(
      JSON.stringify(
        [
          {
            recipient: '0x1234567890123456789012345678901234567890',
            chainNamespace: 'eip155',
            chainId: '11155111',
            amount: '1000000000000000000',
          },
          {
            recipient: '3u1111111111111111111111111111111111111111',
            chainNamespace: 'solana',
            chainId: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
            amount: '2000000000000000000',
          },
        ],
        null,
        2
      )
    );
    process.exit(1);
  }

  // Read airdrop entries
  const entries: AirdropEntry[] = JSON.parse(
    fs.readFileSync(airdropPath, 'utf8')
  );

  // Validate entries
  for (const entry of entries) {
    const isHex =
      entry.recipient.startsWith('0x') && entry.recipient.length === 42;
    const isBase58 = !entry.recipient.startsWith('0x');
    if (!isHex && !isBase58) {
      throw new Error(
        `Invalid recipient: ${entry.recipient} (must be 0x-address or base58)`
      );
    }
    if (!entry.chainNamespace || !entry.chainId) {
      throw new Error(`Missing chain info for ${entry.recipient}`);
    }
    if (isNaN(parseInt(entry.amount)) || BigInt(entry.amount) <= 0) {
      throw new Error(`Invalid amount for ${entry.recipient}: ${entry.amount}`);
    }
  }

  console.log(`üî® Building Merkle tree for ${entries.length} recipients...`);

  // Build Merkle tree
  const treeData = buildMerkleTree(entries);

  // Create output directory
  const outputDir = path.join(__dirname, './data');
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write tree data
  const treePath = path.join(outputDir, 'tree.json');
  fs.writeFileSync(treePath, JSON.stringify(treeData, null, 2));

  console.log('‚úÖ Merkle tree built successfully!');
  console.log(`üíæ Tree data saved to: ${treePath}`);

  // Print summary
  printSummary(treeData);
}

// Export functions for testing
export { generateLeaf, buildMerkleTree, printSummary };

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}
```

### 1.2. Create the airdrop data file

Create the directory structure and input data file:

```bash
mkdir -p merkle-proof-generator/data
```

Create `merkle-proof-generator/data/airdrop.json` with your recipient list:

```json
[
  {
    "recipient": "0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9",
    "chainNamespace": "eip155",
    "chainId": "11155111",
    "amount": "1000000000000000000"
  },
  {
    "recipient": "72JBejJFXrRKpQ69Hmaqr7vWJr6pdZXFEL6jt3sadsXU",
    "chainNamespace": "solana",
    "chainId": "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    "amount": "1500000000000000000"
  },
  {
    "recipient": "0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9",
    "chainNamespace": "eip155",
    "chainId": "42101",
    "amount": "750000000000000000"
  }
]
```

#### Understanding the airdrop.json structure

Each entry in the array represents a recipient with:

- `recipient`: Wallet address (format varies by blockchain)
- `chainNamespace`: Blockchain type ("eip155", "solana", "push", etc.)
- `chainId`: Specific chain identifier within that namespace
- `amount`: Token amount in smallest units (as string to avoid precision issues)

### 1.3. Install dependencies and run the generator

```bash
cd merkle-proof-generator
npx tsx index.ts
```

Example output:

```
üî® Building Merkle tree for 3 recipients...
‚úÖ Merkle tree built successfully!
üíæ Tree data saved to: /Users/fabio/github/push/2-docs-tutorial-merkle-proof/merkle-proof-generator/data/tree.json
üå≥ Universal Airdrop Merkle Tree Summary
=====================================
üìÅ Merkle Root: 0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051
üë• Total Recipients: 3

üìä Per-Chain Breakdown:
  eip155:11155111: 1 recipients, 1000000000000000000 tokens
  solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1: 1 recipients, 1500000000000000000 tokens
  eip155:42101: 1 recipients, 750000000000000000 tokens

üí∞ Total Airdrop Amount: 3250000000000000000 tokens
```

The generator will:

1. Read and validate each entry in `airdrop.json`
2. Generate cryptographic leaves using `keccak256(abi.encodePacked(...))`
3. Build a sorted Merkle tree from all leaves
4. Generate inclusion proofs for each recipient
5. Save the complete tree data to `tree.json`

### 1.4. Understanding the generated tree.json output

After running the generator, you'll get a `merkle-proof-generator/data/tree.json` file with this structure:

```json
{
  "merkleRoot": "0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051",
  "entries": [
    {
      "recipient": "0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9",
      "chainNamespace": "eip155",
      "chainId": "11155111",
      "amount": "1000000000000000000",
      "leaf": "0xdcd8f25fe90a7f166b91017f854f6df5e8efe98da4eeb1a1eb60194d9743448d",
      "proof": [
        "0x1ca10661d30bcbd9a71cdcd967e5d116a34cee6cbd38a2f8318452ef016fce12",
        "0x634cd82dbbdc7e8a5513e306ccd1dedc988e6121ea2a27ceb4414a3cdc76e634"
      ]
    }
  ]
}
```

#### Key components of the output:

- `merkleRoot`: The root hash of the entire Merkle tree
  - Used when deploying the smart contract
  - Acts as a commitment to all airdrop recipients and amounts

- `entries[]`: Array containing each recipient's data plus cryptographic proof
  - `leaf`: The hash of this specific recipient's data
  - `proof[]`: Array of sibling hashes needed to reconstruct the path from leaf to root
    - Used by the smart contract to verify inclusion in the tree
    - Length varies based on tree structure (fewer proofs needed for leaves near the root)

#### How the Merkle proof works:

The proof allows anyone to verify that a specific recipient is included in the airdrop without revealing the entire recipient list. The smart contract can verify the proof by:

1. Recalculating the leaf hash from the recipient's data
2. Using the provided proof hashes to reconstruct the path to the root
3. Comparing the reconstructed root with the stored `merkleRoot`

> ‚úÖ **Next steps**: You'll use the `merkleRoot` when deploying the UniversalAirdrop contract, and the frontend will use each recipient's `proof` array to submit claims on-chain.

## Part 2: Deploy the Merkle airdrop contract

In this part, we'll create a new Hardhat project from scratch, set up the necessary configuration, create our smart contracts, and deploy them to Push Chain Donut Testnet. This includes creating an ERC-20 token contract and a universal airdrop contract that verifies Merkle proofs.

### 2.1. Create a new Hardhat project from scratch

Let's start by creating a fresh Hardhat project for our airdrop contracts:

```bash
# Create the project directory
mkdir contract-airdrop
cd contract-airdrop

# Initialize a new Node.js project
npm init -y

# Install Hardhat and its toolbox
npm install --save-dev hardhat@2.26.3 @nomicfoundation/hardhat-toolbox@6.1.0

# Initialize Hardhat (select the options "Hardhat 2" then "Create a TypeScript project")
npx hardhat init
```

This will create a basic Hardhat project structure with TypeScript support, including:

- `hardhat.config.ts` - Hardhat configuration file
- `contracts/` - Directory for Solidity contracts
- `scripts/` - Directory for deployment scripts
- `test/` - Directory for tests

### 2.2. Install required dependencies

Install the additional dependencies we'll need:

```bash
# Install dotenv for environment variable management
npm install dotenv

# Install OpenZeppelin contracts library
npm install @openzeppelin/contracts
```

- **`dotenv`**: Allows us to load environment variables from a `.env` file, keeping sensitive information like private keys secure
- **`@openzeppelin/contracts`**: Provides battle-tested smart contract implementations including ERC-20, MerkleProof utilities, and access control

### 2.3. Configure Hardhat (`hardhat.config.ts`)

Update your `hardhat.config.ts` to include network configurations and compiler settings:

```typescript
import { HardhatUserConfig } from 'hardhat/config';
import '@nomicfoundation/hardhat-toolbox';
import { config as dotenvConfig } from 'dotenv';

// Load environment variables
dotenvConfig();

const config: HardhatUserConfig = {
  solidity: {
    version: '0.8.22',
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
      viaIR: true,
    },
  },
  networks: {
    pushDonut: {
      url: 'https://evm.rpc-testnet-donut-node1.push.org/',
      accounts: process.env.PRIVATE_KEY
        ? [
            process.env.PRIVATE_KEY.startsWith('0x')
              ? process.env.PRIVATE_KEY
              : `0x${process.env.PRIVATE_KEY}`,
          ]
        : [],
      chainId: 42101,
    },
  },
  paths: {
    sources: './contracts',
    tests: './test',
    cache: './cache',
    artifacts: './artifacts',
  },
};

export default config;
```

**Key configuration details:**

- **Solidity Compiler**: Version 0.8.22 with optimization enabled (200 runs) and viaIR enabled for better gas efficiency
- **Networks**:
  - `pushDonut`: Push Chain Donut Testnet with environment-based private key
- **Paths**: Standard Hardhat directory structure

### 2.4. Create the TestToken contract (`TestToken.sol`)

Create `contracts/TestToken.sol` - a simple ERC-20 token for testing our airdrop:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TestToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1_000_000 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
```

**Understanding the TestToken contract:**

- **Inherits from ERC20**: Uses OpenZeppelin's battle-tested ERC20 implementation
- **Constructor**: Mints 1 million tokens to the deployer upon creation
- **Mint function**: Allows additional tokens to be minted (useful for testing)
- **Standard ERC20 features**: Transfer, balance checking, approvals, etc.

### 2.5. Create the UEAFactory interface for the contracts (`IUEAFactory.sol`)

Create `contracts/interfaces/IUEAFactory.sol` - the interface for the UEAFactory contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

struct UniversalAccountId {
    string chainNamespace;
    string chainId;
    bytes owner;
}

interface IUEAFactory {
    function getOriginForUEA(
        address addr
    ) external view returns (UniversalAccountId memory account, bool isUEA);
}
```

### 2.6. Create the UniversalAirdrop contract (`UniversalAirdrop.sol`)

Create `contracts/UniversalAirdrop.sol` - the main airdrop contract that matches our Merkle proof generator:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./interfaces/IUEAFactory.sol";

/**
 * @title Universal Airdrop Contract for Push Chain
 * @dev Airdrop contract that supports claims from multiple origin chains using UEA (Universal External Accounts)
 * @notice This contract binds claims to the caller's origin chain to prevent cross-chain spoofing
 */
contract UniversalAirdrop is Ownable, ReentrancyGuard {
    // Push Chain UEAFactory address - hardcoded as per specification
    address public constant UEA_FACTORY =
        0x00000000000000000000000000000000000000eA;

    // State variables
    bytes32 public merkleRoot;
    mapping(bytes32 => bool) public claimed; // keyed by claimId to prevent double claims per (address, chainNamespace, chainId)
    IERC20 public immutable token;

    // Push Chain Donut testnet chain ID constant
    string public constant PUSH_CHAIN_ID = "push-donut";

    // Events
    event Claimed(
        address indexed recipient,
        string chainNamespace,
        string chainId,
        uint256 amount
    );
    event MerkleRootUpdated(bytes32 newRoot);

    /**
     * @dev Constructor
     * @param _token The ERC20 token to be airdropped
     * @param _merkleRoot The initial Merkle root for the airdrop
     */
    constructor(IERC20 _token, bytes32 _merkleRoot) Ownable(msg.sender) {
        token = _token;
        merkleRoot = _merkleRoot;
    }

    /**
     * @dev Claim tokens using a Merkle proof
     * @param proof The Merkle proof proving inclusion in the airdrop
     * @param amount The amount of tokens to claim
     * @param chainNamespace The origin chain namespace (e.g., "eip155", "solana", "push")
     * @param chainId The origin chain ID (e.g., "11155111" for Sepolia, "push-donut" for Push)
     * @notice The claim is bound to the caller's origin chain to prevent cross-chain spoofing
     */
    function claim(
        bytes32[] calldata proof,
        uint256 amount,
        string calldata chainNamespace,
        string calldata chainId
    ) external nonReentrant {
        address caller = msg.sender;

        // Get origin chain information from UEAFactory for verification
        (UniversalAccountId memory account, bool isUEA) = IUEAFactory(
            UEA_FACTORY
        ).getOriginForUEA(caller);

        address recipientAddress;

        if (isUEA) {
            // For UEA accounts, verify the provided chain info matches the origin
            require(
                keccak256(abi.encodePacked(chainNamespace)) ==
                    keccak256(abi.encodePacked(account.chainNamespace)) &&
                    keccak256(abi.encodePacked(chainId)) ==
                    keccak256(abi.encodePacked(account.chainId)),
                "Provided chain info does not match UEA origin"
            );
            // Convert owner bytes to address for leaf computation
            // If owner is 20 bytes (EVM), cast directly; otherwise derive address from keccak256(owner)
            if (account.owner.length == 20) {
                recipientAddress = address(bytes20(account.owner));
            } else {
                recipientAddress = address(
                    uint160(uint256(keccak256(account.owner)))
                );
            }
        } else {
            // For non-UEA accounts (could be native Push Chain or direct connections)
            // Allow claiming from any chain - the Merkle proof will verify eligibility
            recipientAddress = caller;
        }

        // Generate claimId to prevent double claims for the same (address, chainNamespace, chainId) tuple
        bytes32 claimId = keccak256(
            abi.encodePacked(recipientAddress, chainNamespace, chainId)
        );
        require(!claimed[claimId], "Already claimed for this origin chain");

        // Compute the leaf as per specification: keccak256(abi.encodePacked(recipientOnPush, chainNamespace, chainId, amount))
        bytes32 leaf = keccak256(
            abi.encodePacked(recipientAddress, chainNamespace, chainId, amount)
        );

        // Verify the Merkle proof
        require(
            MerkleProof.verify(proof, merkleRoot, leaf),
            "Invalid Merkle proof"
        );

        // Mark as claimed and transfer tokens
        claimed[claimId] = true;
        require(
            token.transfer(recipientAddress, amount),
            "Token transfer failed"
        );

        emit Claimed(recipientAddress, chainNamespace, chainId, amount);
    }

    /**
     * @dev Update the Merkle root (only owner)
     * @param newRoot The new Merkle root
     * @notice This allows updating the airdrop with new recipients
     */
    function setMerkleRoot(bytes32 newRoot) external onlyOwner {
        merkleRoot = newRoot;
        emit MerkleRootUpdated(newRoot);
    }

    /**
     * @dev Recover ERC20 tokens (only owner)
     * @param tokenAddress The address of the token to recover
     * @param amount The amount to recover
     * @notice Allows the owner to recover mistakenly sent tokens
     */
    function recoverERC20(
        address tokenAddress,
        uint256 amount
    ) external onlyOwner {
        require(tokenAddress != address(token), "Cannot recover airdrop token");
        IERC20(tokenAddress).transfer(owner(), amount);
    }
}
```

**Key features of the UniversalAirdrop contract:**

- **Merkle Proof Verification**: Uses OpenZeppelin's `MerkleProof.verify()` to validate inclusion proofs
- **Universal Support**: Accepts any recipient address format (the proof generation handles the conversion)
- **Reentrancy Protection**: Uses `ReentrancyGuard` to prevent reentrancy attacks
- **Claim Tracking**: Maps claim IDs (address + origin chain) to prevent double claims per recipient per origin chain
- **Owner Controls**: Allows updating the Merkle root for future airdrop rounds

### 2.7. Create the deployment script (`scripts/deploy.ts`)

Create `scripts/deploy.ts` - a comprehensive deployment script that handles the entire process:

```typescript
import { config } from 'dotenv';
import { ethers } from 'hardhat';
import hre from 'hardhat';
import * as fs from 'fs';
import * as path from 'path';
import { buildMerkleTree } from '../../merkle-proof-generator/index';

// Load environment variables
config();

interface AirdropEntry {
  recipient: string;
  chainNamespace: string;
  chainId: string;
  amount: string;
}

async function main() {
  console.log('üöÄ Starting deployment...');

  // Debug: Check environment and network
  console.log('üîç Checking environment...');
  console.log('üìù PRIVATE_KEY exists:', !!process.env.PRIVATE_KEY);

  // Get the deployer account
  const signers = await ethers.getSigners();
  console.log('üë• Number of signers:', signers.length);

  console.log('Current network:', hre.network.name);

  if (signers.length === 0) {
    console.log('‚ùå Current network:', hre.network.name);
    console.log('‚ùå Network config:', hre.network.config);
    throw new Error(
      'No accounts available. Please check your PRIVATE_KEY in .env file and network configuration.'
    );
  }

  const [deployer] = signers;
  console.log('üìù Deploying contracts with account:', deployer.address);
  console.log(
    'üí∞ Account balance:',
    ethers.formatEther(await ethers.provider.getBalance(deployer.address))
  );

  // Deploy TestToken
  console.log('\nüìÑ Deploying TestToken...');
  const TestToken = await ethers.getContractFactory('TestToken');
  const token = await TestToken.deploy('TestToken1', 'TEST1');
  await token.waitForDeployment();
  const tokenAddress = await token.getAddress();
  console.log('‚úÖ TestToken deployed to:', tokenAddress);

  // Read airdrop entries and generate Merkle tree
  console.log('\nüå≥ Generating Merkle tree...');
  const airdropPath = path.join(
    __dirname,
    '../../merkle-proof-generator/data/airdrop.json'
  );
  const airdropEntries: AirdropEntry[] = JSON.parse(
    fs.readFileSync(airdropPath, 'utf8')
  );
  const treeData = buildMerkleTree(airdropEntries);
  console.log('üìÅ Merkle root:', treeData.merkleRoot);

  // Deploy UniversalAirdrop
  console.log('\nüéØ Deploying UniversalAirdrop...');
  const UniversalAirdrop = await ethers.getContractFactory('UniversalAirdrop');
  const airdrop = await UniversalAirdrop.deploy(
    tokenAddress,
    treeData.merkleRoot
  );
  await airdrop.waitForDeployment();
  const airdropAddress = await airdrop.getAddress();
  console.log('‚úÖ UniversalAirdrop deployed to:', airdropAddress);

  // Calculate total airdrop amount
  const totalAmount = airdropEntries.reduce((sum, entry) => {
    return sum + BigInt(entry.amount);
  }, 0n);

  console.log(
    `\nüí∏ Total airdrop amount: ${ethers.formatEther(totalAmount)} TEST tokens`
  );

  // Transfer tokens to airdrop contract
  console.log('üîÑ Transferring tokens to airdrop contract...');
  const transferTx = await token.transfer(airdropAddress, totalAmount);
  await transferTx.wait();
  console.log('‚úÖ Tokens transferred successfully');

  // Verify balances
  const airdropBalance = await token.balanceOf(airdropAddress);
  const deployerBalance = await token.balanceOf(deployer.address);
  console.log(
    `üè¶ Airdrop contract balance: ${ethers.formatEther(airdropBalance)} TEST`
  );
  console.log(
    `üë§ Deployer balance: ${ethers.formatEther(deployerBalance)} TEST`
  );

  // Save deployment info
  const deploymentInfo = {
    network: await ethers.provider.getNetwork().then((n) => n.name),
    token: {
      address: tokenAddress,
      symbol: 'TEST',
      name: 'TestToken',
    },
    airdrop: {
      address: airdropAddress,
      merkleRoot: treeData.merkleRoot,
    },
    treeData: treeData,
    airdropEntries: airdropEntries,
    totalAmount: ethers.formatEther(totalAmount),
    deployedAt: new Date().toISOString(),
  };

  const deploymentPath = path.join(
    __dirname,
    '../../merkle-proof-generator/data/deployment.json'
  );
  fs.writeFileSync(deploymentPath, JSON.stringify(deploymentInfo, null, 2));
  console.log(`\nüíæ Deployment info saved to: ${deploymentPath}`);

  // Save addresses for the frontend
  const addresses = {
    tokenAddress,
    airdropAddress,
    merkleRoot: treeData.merkleRoot,
  };

  const addressesPath = path.join(
    __dirname,
    '../../merkle-proof-generator/data/addresses.json'
  );
  fs.mkdirSync(path.dirname(addressesPath), { recursive: true });
  fs.writeFileSync(addressesPath, JSON.stringify(addresses, null, 2));
  console.log(`üìÑ Contract addresses saved for frontend: ${addressesPath}`);

  console.log('\nüéâ Deployment completed successfully!');
  console.log('\nüìã Summary:');
  console.log(`   Token Contract: ${tokenAddress}`);
  console.log(`   Airdrop Contract: ${airdropAddress}`);
  console.log(`   Merkle Root: ${treeData.merkleRoot}`);
  console.log(`   Recipients: ${airdropEntries.length}`);
  console.log(`   Total Amount: ${ethers.formatEther(totalAmount)} TEST`);

  console.log('\nüöÄ Next steps:');
  console.log('   1. For local testing: npx hardhat node');
  console.log('   2. Start frontend: npm run dev');
  console.log(
    '   3. Copy tree.json and addresses.json to public/ for frontend access'
  );
  console.log('   4. Visit http://localhost:5173 to claim tokens');
}

// Handle errors
main().catch((error) => {
  console.error('‚ùå Deployment failed:', error);
  process.exitCode = 1;
});
```

**What the deployment script does:**

1. **Environment Check**: Validates that `PRIVATE_KEY` is available
2. **Token Deployment**: Deploys the TestToken contract
3. **Merkle Tree Generation**: Reads airdrop data and generates the Merkle tree using our generator
4. **Airdrop Deployment**: Deploys UniversalAirdrop with the token address and Merkle root
5. **Funding**: Transfers the total airdrop amount to the airdrop contract
6. **Verification**: Checks balances to ensure everything is set up correctly
7. **Data Export**: Creates an `addresses.json` file with deployment information that will be used by the UI. This file contains the following structure:

```json
{
  "tokenAddress": "0xaBd512A0F64986c319eC38EeCEf49EE0EC2a253a",
  "airdropAddress": "0x97449F590D48F76ab472390d5606F0472a9129F7",
  "merkleRoot": "0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051"
}
```

- `tokenAddress`: The deployed ERC-20 token contract address
- `airdropAddress`: The deployed UniversalAirdrop contract address
- `merkleRoot`: The Merkle root hash for verifying airdrop claims

The UI will use this file to interact with the deployed contracts and validate airdrop claims.

### 2.8. Create the .env file

Create a `.env` file in your `contract-airdrop` directory:

```bash
# .env
PRIVATE_KEY=your_private_key
```

### 2.9. Run the deployment

Now you're ready to deploy to Push Chain Donut Testnet:

```bash
# Make sure you're in the contract-airdrop directory
cd contract-airdrop

# Deploy to Push Chain Donut Testnet
npx hardhat run scripts/deploy.ts --network pushDonut
```

**Expected Output:**

```
üöÄ Starting deployment...
üîç Checking environment...
üìù PRIVATE_KEY exists: true
üë• Number of signers: 1
Current network: pushDonut
üìù Deploying contracts with account: 0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9
üí∞ Account balance: 9878.898151033624999941

üìÑ Deploying TestToken...
‚úÖ TestToken deployed to: 0xaBd512A0F64986c319eC38EeCEf49EE0EC2a253a

üå≥ Generating Merkle tree...
üìÅ Merkle root: 0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051

üéØ Deploying UniversalAirdrop...
‚úÖ UniversalAirdrop deployed to: 0x97449F590D48F76ab472390d5606F0472a9129F7

üí∏ Total airdrop amount: 3.25 TEST tokens
üîÑ Transferring tokens to airdrop contract...
‚úÖ Tokens transferred successfully
üè¶ Airdrop contract balance: 3.25 TEST
üë§ Deployer balance: 999996.75 TEST

üíæ Deployment info saved to: .../merkle-proof-generator/data/deployment.json
üìÑ Contract addresses saved for frontend: .../merkle-proof-generator/data/addresses.json

üéâ Deployment completed successfully!

üìã Summary:
   Token Contract: 0xaBd512A0F64986c319eC38EeCEf49EE0EC2a253a
   Airdrop Contract: 0x97449F590D48F76ab472390d5606F0472a9129F7
   Merkle Root: 0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051
   Recipients: 3
   Total Amount: 3.25 TEST

üöÄ Next steps:
   1. For local testing: npx hardhat node
   2. Start frontend: npm run dev
   3. Copy tree.json and addresses.json to public/ for frontend access
   4. Visit http://localhost:5173 to claim tokens
```

After successful deployment, you'll have:

- ‚úÖ **TestToken contract** deployed and funded
- ‚úÖ **UniversalAirdrop contract** deployed with Merkle root
- ‚úÖ **Airdrop contract funded** with tokens for distribution
- ‚úÖ **Deployment data saved** for frontend integration

## Part 3: Build the Claim UI

You'll create a React App that fetches the `tree.json` data and `addresses.json` file (generated previously) to know which addresses to interact with, locates the connected user's airdrop entry, and submits the claim transaction with the cryptographic proof.

### 3.1. Create a Vite React TypeScript Project

First, create a new Vite project with React and TypeScript:

```bash
npm create vite@latest frontend -- --template react-ts
```

Navigate to the project directory and install dependencies:

```bash
cd frontend
npm install
```

### 3.2. Install Push Chain UI Kit SDK

Install the UI Kit SDK to handle wallet connections and user authentication:

```bash
npm install @pushchain/ui-kit
```

### 3.3. Use React v18

Make sure you're using React v18:

```bash
npm install react@18.2.0 react-dom@18.2.0
```

### 3.3. Wrap your app with PushUniversalWalletProvider

Update your `main.tsx` (or equivalent entry file) to wrap your app with the PushUniversalWalletProvider:

```tsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import { PushUniversalWalletProvider, PushUI } from '@pushchain/ui-kit';

const walletConfig = {
  network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET,
};

createRoot(document.getElementById('root')!).render(
  <PushUniversalWalletProvider config={walletConfig}>
    <StrictMode>
      <App />
    </StrictMode>
  </PushUniversalWalletProvider>
);
```

This provider enables wallet connections and user authentication throughout your application.

### 3.4. Expose `tree.json` to your app

Copy `merkle-proof-generator/data/tree.json` and `merkle-proof-generator/data/addresses.json` into your web app‚Äôs static assets (in our case, `frontend/public/`).

### 3.5. Add a minimal Claim component

```jsx live
// customPropMinimized='true'
import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import { makeMerkleTree, getProof } from '@openzeppelin/merkle-tree/dist/core.js';
import { keccak256 } from 'viem';
import bs58 from 'bs58';
import {
  PushUniversalAccountButton,
  usePushWalletContext,
  usePushChainClient,
  PushUI,
  PushUniversalWalletProvider,
} from '@pushchain/ui-kit';
import { PushChain } from '@pushchain/core';

function UniversalAirdrop() {
  // Define Wallet Config
  const walletConfig = {
    network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET,
  };

  // Universal Airdrop Contract ABI - Standard format for PushChain encoding
  const AIRDROP_ABI = [
    {
      inputs: [
        { internalType: 'bytes32[]', name: 'proof', type: 'bytes32[]' },
        { internalType: 'uint256', name: 'amount', type: 'uint256' },
        { internalType: 'string', name: 'chainNamespace', type: 'string' },
        { internalType: 'string', name: 'chainId', type: 'string' },
      ],
      name: 'claim',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ];

  // Chain options for the UI (now used only for display names)
  const CHAIN_OPTIONS = [
    { namespace: 'eip155', id: '11155111', name: 'Ethereum Sepolia' },
    { namespace: 'solana', id: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1', name: 'Solana Devnet' },
    { namespace: 'eip155', id: '42101', name: 'Push Chain Testnet' },
  ];

  // Helper function to get chain name from namespace and id
  const getChainName = (namespace, id) => {
    const chain = CHAIN_OPTIONS.find((chain) => chain.namespace === namespace && chain.id === id);
    return chain ? chain.name : `${namespace}:${id}`;
  };

  // Normalize origin.chain (e.g., 'eip155:42101') to our app's namespace/id scheme
  const normalizeChainFromOrigin = (originChain) => {
    const [ns, chainId] = String(originChain).split(':');

    // No special mapping; tree.json uses 'eip155' with id '42101'

    // Default passthrough (EVM chains, Solana, etc.)
    return { namespace: ns, id: chainId, name: getChainName(ns, chainId) };
  };

  // ---------- Helpers for Merkle tree and origin address mapping ----------

  // Using bs58 package for base58 decoding; custom decoder removed

  const deriveRecipientEvmAddress = (recipientRaw) => {
    try {
      if (recipientRaw.startsWith('0x')) {
        return ethers.getAddress(recipientRaw);
      }
      const raw = Uint8Array.from(bs58.decode(recipientRaw));
      const hashed = keccak256(raw);
      const addressBytes = ethers.dataSlice(hashed, 12);
      return ethers.getAddress(addressBytes);
    } catch {
      throw new Error('Invalid recipient for the selected chain');
    }
  };

  const hashLeaf = (evmRecipient, chainNamespace, chainId, amount) => {
    // Mirror merkle-proof-generator/index.ts manual packed layout
    const recipientBytes = ethers.getBytes(evmRecipient);
    const namespaceBytes = ethers.toUtf8Bytes(chainNamespace);
    const chainIdBytes = ethers.toUtf8Bytes(chainId);
    const amountHex = ethers.toBeHex(amount);
    const amountBytes = ethers.getBytes(ethers.zeroPadValue(amountHex, 32));
    const packed = ethers.concat([recipientBytes, namespaceBytes, chainIdBytes, amountBytes]);
    return keccak256(packed);
  };

  // Pair hashing handled by merkletreejs with sortPairs: true

  // Replaced by merkletreejs usage

  // Replaced by merkletreejs usage

  function Component() {
    // Three-step UI
    const [currentStep, setCurrentStep] = useState(1);

    // User-provided contract addresses
    const [contractAddresses, setContractAddresses] = useState(null);

    // All hooks must be called before any conditional returns
    const [isClaiming, setIsClaiming] = useState(false);
    const [isLoadingProof, setIsLoadingProof] = useState(false);
    const [hasClaimed, setHasClaimed] = useState(false);
    const [claimAmount, setClaimAmount] = useState('');
    const [proof, setProof] = useState([]);
    const [detectedChain, setDetectedChain] = useState(null);
    const [entries, setEntries] = useState([]);
    const [computedEntries, setComputedEntries] = useState([]);
    const [merkleRoot, setMerkleRoot] = useState('');
    const [error, setError] = useState('');
    const [success, setSuccess] = useState('');

    // Push Universal Wallet hooks
    const { connectionStatus } = usePushWalletContext();
    const { pushChainClient } = usePushChainClient();

    // No external JSON loads; everything is user-provided
    useEffect(() => {}, []);

    // Detect chain when connection status changes
    useEffect(() => {
      if (connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED && pushChainClient) {
        // Try to get the origin chain from the Push client
        try {
          console.log('Detecting origin chain from Push client...');
          console.log('Universal object:', pushChainClient.universal);

          if (pushChainClient.universal?.origin) {
            const origin = pushChainClient.universal.origin;
            console.log('Origin from universal.origin:', origin);

            const normalized = normalizeChainFromOrigin(String(origin.chain));
            setDetectedChain(normalized);
            console.log('Detected chain:', normalized);
          } else {
            // Fallback: assume Sepolia if we can't detect
            console.log('Could not detect origin chain, defaulting to Sepolia');
            setDetectedChain({
              namespace: 'eip155',
              id: '11155111',
              name: 'Ethereum Sepolia',
            });
          }
        } catch (err) {
          console.log('Error detecting chain:', err);
          // Fallback: assume Sepolia
          setDetectedChain({
            namespace: 'eip155',
            id: '11155111',
            name: 'Ethereum Sepolia',
          });
        }
      } else {
        setDetectedChain(null);
      }
    }, [connectionStatus, pushChainClient]);

    // Check if address has already claimed for the selected chain
    const checkClaimStatus = useCallback(async () => {
      if (!contractAddresses) return;

      try {
        // For now, we'll use a simple approach - in production you'd use the client's provider
        // This is a simplified version; you might need to adapt based on pushChainClient API
        console.log('Checking claim status with Push Chain client');
        // TODO: Implement claim status check using pushChainClient
      } catch (err) {
        console.error('Error checking claim status:', err);
      }
    }, [contractAddresses]);

    // Load user's proof from computed entries
    const loadUserProof = useCallback(async () => {
      if (!pushChainClient) {
        setError('Wallet not connected');
        return;
      }

      setIsLoadingProof(true);
      setError('');
      setSuccess('');

      try {
        if (!Array.isArray(computedEntries) || computedEntries.length === 0) {
          setError('Please generate the Merkle tree in Step 1 first');
          return;
        }

        console.log('computedEntries', computedEntries);
        console.log('pushChainClient.universal', pushChainClient.universal);

        let currentLookupAddress;
        const origin = pushChainClient.universal?.origin;
        console.log('origin', origin);
        if (origin?.address) {
          currentLookupAddress = origin.address;
          console.log('Using origin address for lookup:', currentLookupAddress);
        } else {
          currentLookupAddress = pushChainClient.universal.account;
          console.log('Origin not available, using UEA address for lookup:', currentLookupAddress);
        }

        if (!currentLookupAddress) {
          setError('Unable to determine lookup address from Push Chain client');
          return;
        }

        console.log('Using lookup address:', currentLookupAddress);
        console.log('Detected chain:', detectedChain);

        if (!detectedChain) {
          setError('Could not detect your origin chain. Please try reconnecting your wallet.');
          return;
        }

        const userEntry = computedEntries.find(
          (entry) =>
            entry.recipient.toLowerCase() === currentLookupAddress.toLowerCase() &&
            entry.chainNamespace === detectedChain.namespace &&
            entry.chainId === detectedChain.id
        );

        console.log('userEntry', userEntry);

        if (userEntry) {
          setProof(userEntry.proof);
          setClaimAmount(ethers.formatEther(userEntry.amountWei));
          setError('');
          setSuccess(`Found your proof for ${detectedChain.name}!`);
        } else {
          setError(
            `No proof found for address ${currentLookupAddress.slice(0, 6)}...${currentLookupAddress.slice(-4)} on ${
              detectedChain.name
            }.`
          );
        }
      } catch (err) {
        setError('Failed to load proof data');
        console.error('Error loading proof:', err);
      } finally {
        setIsLoadingProof(false);
      }
    }, [computedEntries, pushChainClient, detectedChain]);

    // Check claim status and auto-load proof when detected chain changes
    useEffect(() => {
      if (
        connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED &&
        pushChainClient &&
        contractAddresses &&
        detectedChain &&
        computedEntries.length > 0
      ) {
        checkClaimStatus();
        loadUserProof();
      }
    }, [
      detectedChain,
      connectionStatus,
      pushChainClient,
      contractAddresses,
      computedEntries,
      checkClaimStatus,
      loadUserProof,
    ]);

    // Step helpers
    const [newRecipient, setNewRecipient] = useState('');
    const [newChainNamespace, setNewChainNamespace] = useState('eip155');
    const [newChainId, setNewChainId] = useState('11155111');
    const [newAmount, setNewAmount] = useState('');

    const addEntry = () => {
      setError('');
      try {
        if (!newRecipient || !newAmount) {
          setError('Please enter recipient and amount');
          return;
        }
        // quick validation
        if (newChainNamespace === 'eip155' && !/^0x[0-9a-fA-F]{40}$/.test(newRecipient)) {
          setError('Invalid EVM address');
          return;
        }
        if (Number(newAmount) <= 0) {
          setError('Amount must be greater than 0');
          return;
        }
        setEntries((prev) => [
          ...prev,
          {
            recipient: newRecipient.trim(),
            chainNamespace: newChainNamespace,
            chainId: newChainId,
            amount: newAmount.trim(),
          },
        ]);
        setNewRecipient('');
        setNewAmount('');
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Failed to add entry';
        setError(msg);
      }
    };

    const removeEntry = (idx) => {
      setEntries((prev) => prev.filter((_, i) => i !== idx));
    };

    const generateMerkle = () => {
      try {
        setError('');
        setSuccess('');
        if (entries.length === 0) {
          setError('Add at least one entry');
          return;
        }
        const leaves = [];
        const computed = [];

        // build leaves
        for (const entry of entries) {
          const derived = deriveRecipientEvmAddress(entry.recipient);
          const wei = ethers.parseEther(entry.amount);
          const leaf = hashLeaf(derived, entry.chainNamespace, entry.chainId, wei);
          leaves.push(leaf);
          computed.push({
            recipient: entry.recipient,
            chainNamespace: entry.chainNamespace,
            chainId: entry.chainId,
            amount: entry.amount,
            amountWei: wei,
            derivedRecipient: derived,
            leaf,
            proof: [],
          });
        }

        const tree = makeMerkleTree(leaves);
        const root = tree[0];

        for (let i = 0; i < computed.length; i++) {
          const leafTreeIndex = tree.length - 1 - i;
          computed[i].proof = getProof(tree, leafTreeIndex);
        }

        setComputedEntries(computed);
        setMerkleRoot(root);
        setSuccess('Merkle tree generated');
        setCurrentStep(2);
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Failed to generate Merkle tree';
        setError(msg);
      }
    };

    // Claim tokens using Push Universal Transaction
    const claimTokens = async () => {
      if (!pushChainClient || !contractAddresses || !detectedChain) return;
      if (!claimAmount) {
        setError('Please check eligibility to load your claim amount');
        return;
      }

      setIsClaiming(true);
      setError('');
      setSuccess('');

      try {
        const amount = ethers.parseEther(claimAmount);

        // Encode the claim function call
        const claimData = PushChain.utils.helpers.encodeTxData({
          abi: AIRDROP_ABI,
          functionName: 'claim',
          args: [proof, amount, detectedChain.namespace, detectedChain.id],
        });

        console.log('proof', proof);
        console.log('amount', amount);
        console.log('claimData', claimData);

        // Send universal transaction using Push Chain client
        const tx = await pushChainClient.universal.sendTransaction({
          to: contractAddresses.airdropAddress,
          data: claimData,
          value: BigInt('0'), // No PC value needed for claim
        });
        console.log('tx', tx);
        const receipt = await tx.wait();
        console.log('receipt', receipt);

        setSuccess(`Tokens claimed successfully from ${detectedChain.name}! Transaction: ${tx.hash}`);
        setHasClaimed(true);

        // TODO: Update balance using pushChainClient
      } catch (err) {
        const msg = err instanceof Error ? err.message : 'Claim failed';
        setError(msg);
        console.error('Claim error:', err);
      } finally {
        setIsClaiming(false);
      }
    };

    return (
      <div
        style={{
          maxWidth: '500px',
          margin: '0 auto',
          padding: '20px',
          fontFamily: 'system-ui, sans-serif',
        }}
      >
        <h1 style={{ textAlign: 'center', marginBottom: '10px' }}>Universal Airdrop</h1>
        <p style={{ textAlign: 'center', color: '#666', marginBottom: '30px' }}>
          Claim tokens using Push Chain's Universal External Accounts
        </p>

        <div style={{ marginBottom: '30px' }}>
          <PushUniversalAccountButton />
        </div>

        {/* Steps */}
        <div style={{ marginBottom: '24px', display: 'flex', gap: '8px', justifyContent: 'center' }}>
          {[1, 2, 3].map((s) => (
            <div
              key={s}
              style={{
                width: '28px',
                height: '28px',
                borderRadius: '50%',
                backgroundColor: currentStep >= s ? '#646cff' : '#e0e0e0',
                color: currentStep >= s ? '#fff' : '#555',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontWeight: 'bold',
                fontSize: '14px',
              }}
            >
              {s}
            </div>
          ))}
        </div>

        {/* Step 1: Build Merkle tree */}
        <div style={{ marginBottom: '20px', border: '1px solid #eee', borderRadius: '8px', padding: '16px' }}>
          <h3 style={{ marginTop: 0, marginBottom: '12px' }}>Step 1: Create airdrop entries & generate proof</h3>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
            <input
              placeholder="Recipient address (0x... or Solana base58)"
              value={newRecipient}
              onChange={(e) => setNewRecipient(e.target.value)}
              style={{ padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
            />
            <div style={{ display: 'flex', gap: '8px' }}>
              <select
                value={newChainNamespace}
                onChange={(e) => {
                  const ns = e.target.value;
                  setNewChainNamespace(ns);
                  // default chain id based on ns
                  if (ns === 'solana') setNewChainId('EtWTRABZaYq6iMfeYKouRu166VU2xqa1');
                  else setNewChainId('11155111');
                }}
                style={{ flex: 1, padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
              >
                <option value="eip155">EVM (eip155)</option>
                <option value="solana">Solana</option>
              </select>
              <select
                value={newChainId}
                onChange={(e) => setNewChainId(e.target.value)}
                style={{ flex: 1, padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
              >
                <option value="11155111">Ethereum Sepolia</option>
                <option value="42101">Push Chain Testnet</option>
                <option value="EtWTRABZaYq6iMfeYKouRu166VU2xqa1">Solana Devnet</option>
              </select>
            </div>
            <input
              placeholder="Amount (tokens)"
              value={newAmount}
              onChange={(e) => setNewAmount(e.target.value)}
              style={{ padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
            />
            <button
              onClick={addEntry}
              style={{
                width: '100%',
                padding: '12px',
                fontWeight: 'bold',
                backgroundColor: '#646cff',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
              }}
            >
              ‚ûï Add Entry
            </button>
          </div>

          {entries.length > 0 && (
            <div style={{ marginTop: '12px' }}>
              {entries.map((e, i) => (
                <div
                  key={`${e.recipient}-${i}`}
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    padding: '8px',
                    border: '1px solid #eee',
                    borderRadius: '6px',
                    marginBottom: '8px',
                    fontSize: '12px',
                  }}
                >
                  <div>
                    <div style={{ fontFamily: 'monospace' }}>{e.recipient}</div>
                    <div style={{ color: '#666' }}>
                      {e.chainNamespace}:{e.chainId} ¬∑ {e.amount} tokens
                    </div>
                  </div>
                  <button
                    onClick={() => removeEntry(i)}
                    style={{ background: 'transparent', border: 'none', color: '#c62828', cursor: 'pointer' }}
                  >
                    ‚úñ
                  </button>
                </div>
              ))}
              <button
                onClick={generateMerkle}
                style={{
                  width: '100%',
                  padding: '12px',
                  fontWeight: 'bold',
                  backgroundColor: '#2e7d32',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  marginTop: '8px',
                }}
              >
                üå≥ Generate Merkle Tree
              </button>
              {merkleRoot && (
                <div style={{ marginTop: '10px', fontSize: '12px' }}>
                  <div style={{ color: '#666' }}>Merkle Root:</div>
                  <div style={{ fontFamily: 'monospace', wordBreak: 'break-all' }}>{merkleRoot}</div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Step 2: Contract addresses */}
        <div style={{ marginBottom: '20px', border: '1px solid #eee', borderRadius: '8px', padding: '16px' }}>
          <h3 style={{ marginTop: 0, marginBottom: '12px' }}>Step 2: Enter contract addresses</h3>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
            <input
              placeholder="Token contract address (0x...)"
              value={contractAddresses?.tokenAddress || ''}
              onChange={(e) =>
                setContractAddresses({
                  tokenAddress: e.target.value,
                  airdropAddress: contractAddresses?.airdropAddress || '',
                })
              }
              style={{ padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
            />
            <input
              placeholder="Airdrop (Merkle) contract address (0x...)"
              value={contractAddresses?.airdropAddress || ''}
              onChange={(e) =>
                setContractAddresses({
                  tokenAddress: contractAddresses?.tokenAddress || '',
                  airdropAddress: e.target.value,
                })
              }
              style={{ padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
            />
            <button
              onClick={() => setCurrentStep(3)}
              disabled={!merkleRoot || !contractAddresses?.airdropAddress || !contractAddresses?.tokenAddress}
              style={{
                width: '100%',
                padding: '12px',
                fontWeight: 'bold',
                backgroundColor:
                  !merkleRoot || !contractAddresses?.airdropAddress || !contractAddresses?.tokenAddress
                    ? '#ccc'
                    : '#646cff',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor:
                  !merkleRoot || !contractAddresses?.airdropAddress || !contractAddresses?.tokenAddress
                    ? 'not-allowed'
                    : 'pointer',
              }}
            >
              Continue to Step 3
            </button>
          </div>
        </div>

        {/* Step 3: Eligibility & Claim */}
        <div style={{ marginBottom: '20px', border: '1px solid #eee', borderRadius: '8px', padding: '16px' }}>
          <h3 style={{ marginTop: 0, marginBottom: '12px' }}>Step 3: Check eligibility & claim</h3>
          {connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED ? (
            <div>
              <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                <p style={{ marginBottom: '5px', fontSize: '14px', color: '#666' }}>Connected Account</p>
                <p style={{ fontFamily: 'monospace', fontSize: '14px' }}>
                  {pushChainClient?.universal?.account?.slice(0, 8)}...{pushChainClient?.universal?.account?.slice(-6)}
                </p>
              </div>

              <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                <p style={{ marginBottom: '5px', fontSize: '14px', color: '#666' }}>Origin Chain</p>
                <p style={{ fontWeight: 'bold' }}>{detectedChain ? detectedChain.name : 'Detecting...'}</p>
              </div>

              {hasClaimed ? (
                <div
                  style={{
                    padding: '16px',
                    backgroundColor: '#4CAF50',
                    color: 'white',
                    borderRadius: '8px',
                    textAlign: 'center',
                  }}
                >
                  ‚úÖ Tokens claimed successfully!
                </div>
              ) : (
                <div>
                  <button
                    onClick={loadUserProof}
                    disabled={isLoadingProof || !merkleRoot}
                    style={{
                      width: '100%',
                      padding: '12px',
                      fontWeight: 'bold',
                      backgroundColor: isLoadingProof || !merkleRoot ? '#ccc' : '#2196F3',
                      color: 'white',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: isLoadingProof || !merkleRoot ? 'not-allowed' : 'pointer',
                      marginBottom: '12px',
                    }}
                  >
                    {isLoadingProof ? '‚è≥ Loading Your Proof...' : 'üîç Check Eligibility'}
                  </button>

                  {!isLoadingProof && !claimAmount && (
                    <div
                      style={{
                        padding: '16px',
                        backgroundColor: '#fff3cd',
                        color: '#856404',
                        borderRadius: '6px',
                        marginBottom: '16px',
                        textAlign: 'center',
                      }}
                    >
                      ‚ö†Ô∏è No tokens available to claim on this chain
                    </div>
                  )}

                  {claimAmount && (
                    <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                      <div
                        style={{
                          display: 'inline-block',
                          backgroundColor: '#f0f8ff',
                          padding: '12px 20px',
                          borderRadius: '8px',
                          border: '2px solid #646cff',
                        }}
                      >
                        <p style={{ margin: '0 0 4px 0', fontSize: '12px', color: '#666', fontWeight: 'bold' }}>
                          CLAIM AMOUNT
                        </p>
                        <p style={{ margin: 0, fontSize: '24px', fontWeight: 'bold', color: '#646cff' }}>
                          {claimAmount} <span style={{ fontSize: '16px', color: '#666' }}>TOKENS</span>
                        </p>
                      </div>
                    </div>
                  )}

                  <button
                    onClick={claimTokens}
                    disabled={isClaiming || isLoadingProof || !claimAmount}
                    style={{
                      width: '100%',
                      padding: '16px',
                      fontSize: '18px',
                      fontWeight: 'bold',
                      backgroundColor: isClaiming || isLoadingProof || !claimAmount ? '#ccc' : '#646cff',
                      color: 'white',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: isClaiming || isLoadingProof || !claimAmount ? 'not-allowed' : 'pointer',
                      transition: 'all 0.2s ease',
                      transform: isClaiming || isLoadingProof || !claimAmount ? 'none' : 'scale(1)',
                      boxShadow:
                        isClaiming || isLoadingProof || !claimAmount ? 'none' : '0 4px 12px rgba(100, 108, 255, 0.3)',
                    }}
                  >
                    {isClaiming ? '‚è≥ Claiming Tokens...' : `üöÄ Claim ${claimAmount || '0'} Tokens`}
                  </button>
                </div>
              )}
            </div>
          ) : (
            <div style={{ padding: '12px', background: '#fff3cd', color: '#856404', borderRadius: '6px' }}>
              Connect your wallet to check eligibility
            </div>
          )}
        </div>

        {error && (
          <div
            style={{
              padding: '12px',
              backgroundColor: '#ffebee',
              color: '#c62828',
              borderRadius: '6px',
              marginTop: '20px',
              textAlign: 'center',
            }}
          >
            {error}
          </div>
        )}

        {success && (
          <div
            style={{
              padding: '12px',
              backgroundColor: '#e8f5e8',
              color: '#2e7d32',
              borderRadius: '6px',
              marginTop: '20px',
              textAlign: 'center',
            }}
          >
            {success}
          </div>
        )}

        <div style={{ marginTop: '30px', padding: '16px', backgroundColor: '#f8f9fa', borderRadius: '8px' }}>
          <p style={{ fontSize: '14px', color: '#666', margin: 0, textAlign: 'center' }}>
            Build your airdrop list, enter contract addresses, then connect and claim
          </p>
        </div>
      </div>
    );
  }
  return (
    <PushUniversalWalletProvider config={walletConfig}>
      <Component />
    </PushUniversalWalletProvider>
  );
}
```

## Conclusion

You generated **Merkle proofs** from an airdrop list, deployed a **Universal Merkle‚Äëverified airdrop contract** to **Push Chain Donut Testnet**, and added a **claim UI**. With this universal airdrop system, users from different chains can claim their tokens seamlessly using Push Chain's Universal External Accounts (UEA) system.

---
id: docs-chain-tutorials-universal-airdrop
title: 'Build a Claimable Universal Airdrop'
hide_title: false
slug: ./tutorial-universal-airdrop
displayed_sidebar: pushChainSidebar
sidebar_position: 6
image: '/assets/docs/previews/docs_chain_tutorials_universal_airdrop--build_a_universal_airdrop:_proofs,_contract,_and_claim_ui.png'
---

<head>
  <title>{`Build a Universal Airdrop: Generate Merkle Proofs, Deploy Contract, and Add a Claim UI | Tutorials | Push Chain Docs`}</title>
</head>

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Details from '@theme/Details';
import PushAPIReference from '@site/src/components/PushAPIReference/PushAPIReference';
import NodeJSVirtualIDE from '@site/src/components/NodeJSVirtualIDE/NodeJSVirtualIDE';
import RemixIDE from '@site/src/components/RemixIDE/RemixIDE';

{/* Content Start */}

Welcome! In this tutorial, you'll build a **Universal Airdrop** system that revolutionizes cross-chain token distribution. Unlike traditional airdrops that require deploying contracts on every blockchain, this universal approach lets you **deploy once on Push Chain** and enable users from **any blockchain** (Ethereum, Solana, Polygon, etc.) to claim their tokens seamlessly.

## Why Universal Airdrops?

The beauty of this system lies in its efficiency and cross-chain compatibility:

- **Single Deployment**: Deploy your airdrop contract once on Push Chain instead of managing multiple contracts across different networks
- **Cross-Chain Claims**: Users from Ethereum, Solana, Polygon, and other chains can all claim tokens from the same contract
- **No Multi-Chain Token Deployment**: Keep your ERC-20 token on one chain while enabling universal claiming
- **User Simplicity**: Recipients can claim their tokens using their preferred wallet on their own chain, making the process seamless and familiar

We'll build the complete flow:

1. Generate Merkle proofs with cross-chain recipient data
2. Deploy a universal Merkle claim contract to Push Chain
3. Create a UI for recipients to claim their tokens from any chain

<Tabs className="liveplaytab" groupId="send-universal-transaction-coding">
  <TabItem value='Full Application' label='Full Application'>

```jsx live
// customPropMinimized='true'
import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import { makeMerkleTree, getProof } from '@openzeppelin/merkle-tree/dist/core.js';
import { keccak256 } from 'viem';
import bs58 from 'bs58';
import {
  PushUniversalAccountButton,
  usePushWalletContext,
  usePushChainClient,
  PushUI,
  PushUniversalWalletProvider,
} from '@pushchain/ui-kit';
import { PushChain } from '@pushchain/core';

function UniversalAirdrop() {
  // Define Wallet Config
  const walletConfig = {
    network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET,
  };

  // Universal Airdrop Contract ABI - Standard format for PushChain encoding
  const AIRDROP_ABI = [
    {
      inputs: [
        { internalType: 'bytes32[]', name: 'proof', type: 'bytes32[]' },
        { internalType: 'uint256', name: 'amount', type: 'uint256' },
        { internalType: 'string', name: 'chainNamespace', type: 'string' },
        { internalType: 'string', name: 'chainId', type: 'string' },
      ],
      name: 'claim',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ];

  // Chain options for the UI (now used only for display names)
  const CHAIN_OPTIONS = [
    { namespace: 'eip155', id: '11155111', name: 'Ethereum Sepolia' },
    { namespace: 'solana', id: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1', name: 'Solana Devnet' },
    { namespace: 'eip155', id: '42101', name: 'Push Chain Testnet' },
  ];

  // Helper function to get chain name from namespace and id
  const getChainName = (namespace, id) => {
    const chain = CHAIN_OPTIONS.find((chain) => chain.namespace === namespace && chain.id === id);
    return chain ? chain.name : `${namespace}:${id}`;
  };

  // Normalize origin.chain (e.g., 'eip155:42101') to our app's namespace/id scheme
  const normalizeChainFromOrigin = (originChain) => {
    const [ns, chainId] = String(originChain).split(':');

    // No special mapping; tree.json uses 'eip155' with id '42101'

    // Default passthrough (EVM chains, Solana, etc.)
    return { namespace: ns, id: chainId, name: getChainName(ns, chainId) };
  };

  // ---------- Helpers for Merkle tree and origin address mapping ----------

  // Using bs58 package for base58 decoding; custom decoder removed

  const deriveRecipientEvmAddress = (recipientRaw) => {
    try {
      if (recipientRaw.startsWith('0x')) {
        return ethers.getAddress(recipientRaw);
      }
      const raw = Uint8Array.from(bs58.decode(recipientRaw));
      const hashed = keccak256(raw);
      const addressBytes = ethers.dataSlice(hashed, 12);
      return ethers.getAddress(addressBytes);
    } catch {
      throw new Error('Invalid recipient for the selected chain');
    }
  };

  const hashLeaf = (evmRecipient, chainNamespace, chainId, amount) => {
    // Mirror merkle-proof-generator/index.ts manual packed layout
    const recipientBytes = ethers.getBytes(evmRecipient);
    const namespaceBytes = ethers.toUtf8Bytes(chainNamespace);
    const chainIdBytes = ethers.toUtf8Bytes(chainId);
    const amountHex = ethers.toBeHex(amount);
    const amountBytes = ethers.getBytes(ethers.zeroPadValue(amountHex, 32));
    const packed = ethers.concat([recipientBytes, namespaceBytes, chainIdBytes, amountBytes]);
    return keccak256(packed);
  };

  function Component() {
    // Three-step UI
    const [currentStep, setCurrentStep] = useState(1);

    // User-provided contract addresses
    const [contractAddresses, setContractAddresses] = useState(null);

    // All hooks must be called before any conditional returns
    const [isClaiming, setIsClaiming] = useState(false);
    const [isLoadingProof, setIsLoadingProof] = useState(false);
    const [hasClaimed, setHasClaimed] = useState(false);
    const [claimAmount, setClaimAmount] = useState('');
    const [proof, setProof] = useState([]);
    const [detectedChain, setDetectedChain] = useState(null);
    const [entries, setEntries] = useState([]);
    const [computedEntries, setComputedEntries] = useState([]);
    const [merkleRoot, setMerkleRoot] = useState('');
    const [error, setError] = useState('');
    const [success, setSuccess] = useState('');

    // Push Universal Wallet hooks
    const { connectionStatus } = usePushWalletContext();
    const { pushChainClient } = usePushChainClient();

    // No external JSON loads; everything is user-provided
    useEffect(() => {}, []);

    // Detect chain when connection status changes
    useEffect(() => {
      if (connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED && pushChainClient) {
        // Try to get the origin chain from the Push client
        try {
          console.log('Detecting origin chain from Push client...');
          console.log('Universal object:', pushChainClient.universal);

          if (pushChainClient.universal?.origin) {
            const origin = pushChainClient.universal.origin;
            console.log('Origin from universal.origin:', origin);

            const normalized = normalizeChainFromOrigin(String(origin.chain));
            setDetectedChain(normalized);
            console.log('Detected chain:', normalized);
          } else {
            // Fallback: assume Sepolia if we can't detect
            console.log('Could not detect origin chain, defaulting to Sepolia');
            setDetectedChain({
              namespace: 'eip155',
              id: '11155111',
              name: 'Ethereum Sepolia',
            });
          }
        } catch (err) {
          console.log('Error detecting chain:', err);
          // Fallback: assume Sepolia
          setDetectedChain({
            namespace: 'eip155',
            id: '11155111',
            name: 'Ethereum Sepolia',
          });
        }
      } else {
        setDetectedChain(null);
      }
    }, [connectionStatus, pushChainClient]);

    // Check if address has already claimed for the selected chain
    const checkClaimStatus = useCallback(async () => {
      if (!contractAddresses) return;

      try {
        // For now, we'll use a simple approach - in production you'd use the client's provider
        // This is a simplified version; you might need to adapt based on pushChainClient API
        console.log('Checking claim status with Push Chain client');
        // TODO: Implement claim status check using pushChainClient
      } catch (err) {
        console.error('Error checking claim status:', err);
      }
    }, [contractAddresses]);

    // Load user's proof from computed entries
    const loadUserProof = useCallback(async () => {
      if (!pushChainClient) {
        setError('Wallet not connected');
        return;
      }

      setIsLoadingProof(true);
      setError('');
      setSuccess('');

      try {
        if (!Array.isArray(computedEntries) || computedEntries.length === 0) {
          setError('Please generate the Merkle tree in Step 1 first');
          return;
        }

        console.log('computedEntries', computedEntries);
        console.log('pushChainClient.universal', pushChainClient.universal);

        let currentLookupAddress;
        const origin = pushChainClient.universal?.origin;
        console.log('origin', origin);
        if (origin?.address) {
          currentLookupAddress = origin.address;
          console.log('Using origin address for lookup:', currentLookupAddress);
        } else {
          currentLookupAddress = pushChainClient.universal.account;
          console.log('Origin not available, using UEA address for lookup:', currentLookupAddress);
        }

        if (!currentLookupAddress) {
          setError('Unable to determine lookup address from Push Chain client');
          return;
        }

        console.log('Using lookup address:', currentLookupAddress);
        console.log('Detected chain:', detectedChain);

        if (!detectedChain) {
          setError('Could not detect your origin chain. Please try reconnecting your wallet.');
          return;
        }

        const userEntry = computedEntries.find(
          (entry) =>
            entry.recipient.toLowerCase() === currentLookupAddress.toLowerCase() &&
            entry.chainNamespace === detectedChain.namespace &&
            entry.chainId === detectedChain.id
        );

        console.log('userEntry', userEntry);

        if (userEntry) {
          setProof(userEntry.proof);
          setClaimAmount(ethers.formatEther(userEntry.amountWei));
          setError('');
          setSuccess(`Found your proof for ${detectedChain.name}!`);
        } else {
          setError(
            `No proof found for address ${currentLookupAddress.slice(0, 6)}...${currentLookupAddress.slice(-4)} on ${
              detectedChain.name
            }.`
          );
        }
      } catch (err) {
        setError('Failed to load proof data');
        console.error('Error loading proof:', err);
      } finally {
        setIsLoadingProof(false);
      }
    }, [computedEntries, pushChainClient, detectedChain]);

    // Check claim status and auto-load proof when detected chain changes
    useEffect(() => {
      if (
        connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED &&
        pushChainClient &&
        contractAddresses &&
        detectedChain &&
        computedEntries.length > 0
      ) {
        checkClaimStatus();
        loadUserProof();
      }
    }, [
      detectedChain,
      connectionStatus,
      pushChainClient,
      contractAddresses,
      computedEntries,
      checkClaimStatus,
      loadUserProof,
    ]);

    // Step helpers
    const [newRecipient, setNewRecipient] = useState('');
    const [newChainNamespace, setNewChainNamespace] = useState('eip155');
    const [newChainId, setNewChainId] = useState('11155111');
    const [newAmount, setNewAmount] = useState('');

    const addEntry = () => {
      setError('');
      try {
        if (!newRecipient || !newAmount) {
          setError('Please enter recipient and amount');
          return;
        }
        // quick validation
        if (newChainNamespace === 'eip155' && !/^0x[0-9a-fA-F]{40}$/.test(newRecipient)) {
          setError('Invalid EVM address');
          return;
        }
        if (Number(newAmount) <= 0) {
          setError('Amount must be greater than 0');
          return;
        }
        setEntries((prev) => [
          ...prev,
          {
            recipient: newRecipient.trim(),
            chainNamespace: newChainNamespace,
            chainId: newChainId,
            amount: newAmount.trim(),
          },
        ]);
        setNewRecipient('');
        setNewAmount('');
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Failed to add entry';
        setError(msg);
      }
    };

    const removeEntry = (idx) => {
      setEntries((prev) => prev.filter((_, i) => i !== idx));
    };

    const generateMerkle = () => {
      try {
        setError('');
        setSuccess('');
        if (entries.length === 0) {
          setError('Add at least one entry');
          return;
        }
        const leaves = [];
        const computed = [];

        // build leaves
        for (const entry of entries) {
          const derived = deriveRecipientEvmAddress(entry.recipient);
          const wei = ethers.parseEther(entry.amount);
          const leaf = hashLeaf(derived, entry.chainNamespace, entry.chainId, wei);
          leaves.push(leaf);
          computed.push({
            recipient: entry.recipient,
            chainNamespace: entry.chainNamespace,
            chainId: entry.chainId,
            amount: entry.amount,
            amountWei: wei,
            derivedRecipient: derived,
            leaf,
            proof: [],
          });
        }

        const tree = makeMerkleTree(leaves);
        const root = tree[0];

        for (let i = 0; i < computed.length; i++) {
          const leafTreeIndex = tree.length - 1 - i;
          computed[i].proof = getProof(tree, leafTreeIndex);
        }

        setComputedEntries(computed);
        setMerkleRoot(root);
        setSuccess('Merkle tree generated');
        setCurrentStep(2);
      } catch (e) {
        const msg = e instanceof Error ? e.message : 'Failed to generate Merkle tree';
        setError(msg);
      }
    };

    // Claim tokens using Push Universal Transaction
    const claimTokens = async () => {
      if (!pushChainClient || !contractAddresses || !detectedChain) return;
      if (!claimAmount) {
        setError('Please check eligibility to load your claim amount');
        return;
      }

      setIsClaiming(true);
      setError('');
      setSuccess('');

      try {
        const amount = ethers.parseEther(claimAmount);

        // Encode the claim function call
        const claimData = PushChain.utils.helpers.encodeTxData({
          abi: AIRDROP_ABI,
          functionName: 'claim',
          args: [proof, amount, detectedChain.namespace, detectedChain.id],
        });

        console.log('proof', proof);
        console.log('amount', amount);
        console.log('claimData', claimData);

        // Send universal transaction using Push Chain client
        const tx = await pushChainClient.universal.sendTransaction({
          to: contractAddresses.airdropAddress,
          data: claimData,
          value: BigInt('0'), // No PC value needed for claim
        });
        console.log('tx', tx);
        const receipt = await tx.wait();
        console.log('receipt', receipt);

        setSuccess(`Tokens claimed successfully from ${detectedChain.name}! Transaction: ${tx.hash}`);
        setHasClaimed(true);

        // TODO: Update balance using pushChainClient
      } catch (err) {
        const msg = err instanceof Error ? err.message : 'Claim failed';
        setError(msg);
        console.error('Claim error:', err);
      } finally {
        setIsClaiming(false);
      }
    };

    return (
      <div
        style={{
          maxWidth: '500px',
          margin: '0 auto',
          padding: '20px',
          fontFamily: 'system-ui, sans-serif',
        }}
      >
        <h1 style={{ textAlign: 'center', marginBottom: '10px' }}>Universal Airdrop</h1>
        <p style={{ textAlign: 'center', color: '#666', marginBottom: '30px' }}>
          Claim tokens using Push Chain's Universal External Accounts
        </p>

        <div style={{ marginBottom: '30px' }}>
          <PushUniversalAccountButton />
        </div>

        {/* Steps */}
        <div style={{ marginBottom: '24px', display: 'flex', gap: '8px', justifyContent: 'center' }}>
          {[1, 2, 3].map((s) => (
            <div
              key={s}
              style={{
                width: '28px',
                height: '28px',
                borderRadius: '50%',
                backgroundColor: currentStep >= s ? '#646cff' : '#e0e0e0',
                color: currentStep >= s ? '#fff' : '#555',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontWeight: 'bold',
                fontSize: '14px',
              }}
            >
              {s}
            </div>
          ))}
        </div>

        {/* Step 1: Build Merkle tree */}
        <div style={{ marginBottom: '20px', border: '1px solid #eee', borderRadius: '8px', padding: '16px' }}>
          <h3 style={{ marginTop: 0, marginBottom: '12px' }}>Step 1: Create airdrop entries & generate proof</h3>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
            <input
              placeholder="Recipient address (0x... or Solana base58)"
              value={newRecipient}
              onChange={(e) => setNewRecipient(e.target.value)}
              style={{ padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
            />
            <div style={{ display: 'flex', gap: '8px' }}>
              <select
                value={newChainNamespace}
                onChange={(e) => {
                  const ns = e.target.value;
                  setNewChainNamespace(ns);
                  // default chain id based on ns
                  if (ns === 'solana') setNewChainId('EtWTRABZaYq6iMfeYKouRu166VU2xqa1');
                  else setNewChainId('11155111');
                }}
                style={{ flex: 1, padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
              >
                <option value="eip155">EVM (eip155)</option>
                <option value="solana">Solana</option>
              </select>
              <select
                value={newChainId}
                onChange={(e) => setNewChainId(e.target.value)}
                style={{ flex: 1, padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
              >
                <option value="11155111">Ethereum Sepolia</option>
                <option value="42101">Push Chain Testnet</option>
                <option value="EtWTRABZaYq6iMfeYKouRu166VU2xqa1">Solana Devnet</option>
              </select>
            </div>
            <input
              placeholder="Amount (tokens)"
              value={newAmount}
              onChange={(e) => setNewAmount(e.target.value)}
              style={{ padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
            />
            <button
              onClick={addEntry}
              style={{
                width: '100%',
                padding: '12px',
                fontWeight: 'bold',
                backgroundColor: '#646cff',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
              }}
            >
              ➕ Add Entry
            </button>
          </div>

          {entries.length > 0 && (
            <div style={{ marginTop: '12px' }}>
              {entries.map((e, i) => (
                <div
                  key={`${e.recipient}-${i}`}
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    padding: '8px',
                    border: '1px solid #eee',
                    borderRadius: '6px',
                    marginBottom: '8px',
                    fontSize: '12px',
                  }}
                >
                  <div>
                    <div style={{ fontFamily: 'monospace' }}>{e.recipient}</div>
                    <div style={{ color: '#666' }}>
                      {e.chainNamespace}:{e.chainId} · {e.amount} tokens
                    </div>
                  </div>
                  <button
                    onClick={() => removeEntry(i)}
                    style={{ background: 'transparent', border: 'none', color: '#c62828', cursor: 'pointer' }}
                  >
                    ✖
                  </button>
                </div>
              ))}
              <button
                onClick={generateMerkle}
                style={{
                  width: '100%',
                  padding: '12px',
                  fontWeight: 'bold',
                  backgroundColor: '#2e7d32',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  marginTop: '8px',
                }}
              >
                🌳 Generate Merkle Tree
              </button>
              {merkleRoot && (
                <div style={{ marginTop: '10px', fontSize: '12px' }}>
                  <div style={{ color: '#666' }}>Merkle Root:</div>
                  <div style={{ fontFamily: 'monospace', wordBreak: 'break-all' }}>{merkleRoot}</div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Step 2: Contract addresses */}
        <div style={{ marginBottom: '20px', border: '1px solid #eee', borderRadius: '8px', padding: '16px' }}>
          <h3 style={{ marginTop: 0, marginBottom: '12px' }}>Step 2: Enter contract addresses</h3>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
            <input
              placeholder="Token contract address (0x...)"
              value={contractAddresses?.tokenAddress || ''}
              onChange={(e) =>
                setContractAddresses({
                  tokenAddress: e.target.value,
                  airdropAddress: contractAddresses?.airdropAddress || '',
                })
              }
              style={{ padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
            />
            <input
              placeholder="Airdrop (Merkle) contract address (0x...)"
              value={contractAddresses?.airdropAddress || ''}
              onChange={(e) =>
                setContractAddresses({
                  tokenAddress: contractAddresses?.tokenAddress || '',
                  airdropAddress: e.target.value,
                })
              }
              style={{ padding: '10px', borderRadius: '6px', border: '1px solid #ddd' }}
            />
            <button
              onClick={() => setCurrentStep(3)}
              disabled={!merkleRoot || !contractAddresses?.airdropAddress || !contractAddresses?.tokenAddress}
              style={{
                width: '100%',
                padding: '12px',
                fontWeight: 'bold',
                backgroundColor:
                  !merkleRoot || !contractAddresses?.airdropAddress || !contractAddresses?.tokenAddress
                    ? '#ccc'
                    : '#646cff',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor:
                  !merkleRoot || !contractAddresses?.airdropAddress || !contractAddresses?.tokenAddress
                    ? 'not-allowed'
                    : 'pointer',
              }}
            >
              Continue to Step 3
            </button>
          </div>
        </div>

        {/* Step 3: Eligibility & Claim */}
        <div style={{ marginBottom: '20px', border: '1px solid #eee', borderRadius: '8px', padding: '16px' }}>
          <h3 style={{ marginTop: 0, marginBottom: '12px' }}>Step 3: Check eligibility & claim</h3>
          {connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED ? (
            <div>
              <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                <p style={{ marginBottom: '5px', fontSize: '14px', color: '#666' }}>Connected Account</p>
                <p style={{ fontFamily: 'monospace', fontSize: '14px' }}>
                  {pushChainClient?.universal?.account?.slice(0, 8)}...{pushChainClient?.universal?.account?.slice(-6)}
                </p>
              </div>

              <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                <p style={{ marginBottom: '5px', fontSize: '14px', color: '#666' }}>Origin Chain</p>
                <p style={{ fontWeight: 'bold' }}>{detectedChain ? detectedChain.name : 'Detecting...'}</p>
              </div>

              {hasClaimed ? (
                <div
                  style={{
                    padding: '16px',
                    backgroundColor: '#4CAF50',
                    color: 'white',
                    borderRadius: '8px',
                    textAlign: 'center',
                  }}
                >
                  ✅ Tokens claimed successfully!
                </div>
              ) : (
                <div>
                  <button
                    onClick={loadUserProof}
                    disabled={isLoadingProof || !merkleRoot}
                    style={{
                      width: '100%',
                      padding: '12px',
                      fontWeight: 'bold',
                      backgroundColor: isLoadingProof || !merkleRoot ? '#ccc' : '#2196F3',
                      color: 'white',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: isLoadingProof || !merkleRoot ? 'not-allowed' : 'pointer',
                      marginBottom: '12px',
                    }}
                  >
                    {isLoadingProof ? '⏳ Loading Your Proof...' : '🔍 Check Eligibility'}
                  </button>

                  {!isLoadingProof && !claimAmount && (
                    <div
                      style={{
                        padding: '16px',
                        backgroundColor: '#fff3cd',
                        color: '#856404',
                        borderRadius: '6px',
                        marginBottom: '16px',
                        textAlign: 'center',
                      }}
                    >
                      ⚠️ No tokens available to claim on this chain
                    </div>
                  )}

                  {claimAmount && (
                    <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                      <div
                        style={{
                          display: 'inline-block',
                          backgroundColor: '#f0f8ff',
                          padding: '12px 20px',
                          borderRadius: '8px',
                          border: '2px solid #646cff',
                        }}
                      >
                        <p style={{ margin: '0 0 4px 0', fontSize: '12px', color: '#666', fontWeight: 'bold' }}>
                          CLAIM AMOUNT
                        </p>
                        <p style={{ margin: 0, fontSize: '24px', fontWeight: 'bold', color: '#646cff' }}>
                          {claimAmount} <span style={{ fontSize: '16px', color: '#666' }}>TOKENS</span>
                        </p>
                      </div>
                    </div>
                  )}

                  <button
                    onClick={claimTokens}
                    disabled={isClaiming || isLoadingProof || !claimAmount}
                    style={{
                      width: '100%',
                      padding: '16px',
                      fontSize: '18px',
                      fontWeight: 'bold',
                      backgroundColor: isClaiming || isLoadingProof || !claimAmount ? '#ccc' : '#646cff',
                      color: 'white',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: isClaiming || isLoadingProof || !claimAmount ? 'not-allowed' : 'pointer',
                      transition: 'all 0.2s ease',
                      transform: isClaiming || isLoadingProof || !claimAmount ? 'none' : 'scale(1)',
                      boxShadow:
                        isClaiming || isLoadingProof || !claimAmount ? 'none' : '0 4px 12px rgba(100, 108, 255, 0.3)',
                    }}
                  >
                    {isClaiming ? '⏳ Claiming Tokens...' : `🚀 Claim ${claimAmount || '0'} Tokens`}
                  </button>
                </div>
              )}
            </div>
          ) : (
            <div style={{ padding: '12px', background: '#fff3cd', color: '#856404', borderRadius: '6px' }}>
              Connect your wallet to check eligibility
            </div>
          )}
        </div>

        {error && (
          <div
            style={{
              padding: '12px',
              backgroundColor: '#ffebee',
              color: '#c62828',
              borderRadius: '6px',
              marginTop: '20px',
              textAlign: 'center',
            }}
          >
            {error}
          </div>
        )}

        {success && (
          <div
            style={{
              padding: '12px',
              backgroundColor: '#e8f5e8',
              color: '#2e7d32',
              borderRadius: '6px',
              marginTop: '20px',
              textAlign: 'center',
            }}
          >
            {success}
          </div>
        )}

        <div style={{ marginTop: '30px', padding: '16px', backgroundColor: '#f8f9fa', borderRadius: '8px' }}>
          <p style={{ fontSize: '14px', color: '#666', margin: 0, textAlign: 'center' }}>
            Build your airdrop list, enter contract addresses, then connect and claim
          </p>
        </div>
      </div>
    );
  }
  return (
    <PushUniversalWalletProvider config={walletConfig}>
      <Component />
    </PushUniversalWalletProvider>
  );
}
```

</TabItem>
<TabItem value='Deploy ERC-20 Token' label='Deploy ERC-20 Token'>

- Set the Solidity compiler version to 0.8.22 in Remix.
- For Environment, choose Injected Provider (connect your wallet to Push Chain Donut Testnet).
- When deploying `TestToken`, pass constructor arguments: token name and symbol (e.g., `TestToken` and `TEST`).

<RemixIDE
  examples={{
    'TestToken.sol': {
      absoluteFileURL:
        'https://github.com/pushchain/push-chain-examples/blob/main/tutorials/universal-airdrop/contracts/TestToken.sol',
      ctaTitle: 'View on GitHub',
      ctaURL:
        'https://github.com/pushchain/push-chain-examples/blob/main/tutorials/universal-airdrop/contracts/TestToken.sol',
    },
  }}
/>

<br />

### Create the TestToken contract (`TestToken.sol`)

Here is the `TestToken.sol` - a simple ERC-20 token for testing our airdrop:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TestToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1_000_000 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
```

**Understanding the TestToken contract:**

- **Inherits from ERC20**: Uses OpenZeppelin's battle-tested ERC20 implementation
- **Constructor**: Mints 1 million tokens to the deployer upon creation
- **Mint function**: Allows additional tokens to be minted (useful for testing)
- **Standard ERC20 features**: Transfer, balance checking, approvals, etc.

</TabItem>
<TabItem value='Deploy Universal Airdrop' label='Deploy Universal Airdrop'>

- Set the Solidity compiler version to 0.8.22 in Remix.
- For Environment, choose Injected Provider (connect your wallet to Push Chain Donut Testnet).
- When deploying `UniversalAirdrop`, pass constructor arguments: token address deployed in the previous step and merkle root.

<RemixIDE
  examples={{
    'UniversalAirdrop.sol': {
      absoluteFileURL:
        'https://github.com/pushchain/push-chain-examples/blob/main/tutorials/universal-airdrop/contracts/UniversalAirdrop.sol',
      ctaTitle: 'View on GitHub',
      ctaURL:
        'https://github.com/pushchain/push-chain-examples/blob/main/tutorials/universal-airdrop/contracts/UniversalAirdrop.sol',
    },
  }}
/>

<br />
### Create the UEAFactory interface for the contracts (`IUEAFactory.sol`)

Here is the `IUEAFactory.sol` - the interface for the UEAFactory contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

struct UniversalAccountId {
    string chainNamespace;
    string chainId;
    bytes owner;
}

interface IUEAFactory {
    function getOriginForUEA(
        address addr
    ) external view returns (UniversalAccountId memory account, bool isUEA);
}
```

### Create the UniversalAirdrop contract (`UniversalAirdrop.sol`)

Here is the `UniversalAirdrop.sol` - the main airdrop contract that matches our Merkle proof generator:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./interfaces/IUEAFactory.sol";

/**
 * @title Universal Airdrop Contract for Push Chain
 * @dev Airdrop contract that supports claims from multiple origin chains using UEA (Universal External Accounts)
 * @notice This contract binds claims to the caller's origin chain to prevent cross-chain spoofing
 */
contract UniversalAirdrop is Ownable, ReentrancyGuard {
    // Push Chain UEAFactory address - hardcoded as per specification
    address public constant UEA_FACTORY =
        0x00000000000000000000000000000000000000eA;

    // State variables
    bytes32 public merkleRoot;
    mapping(bytes32 => bool) public claimed; // keyed by claimId to prevent double claims per (address, chainNamespace, chainId)
    IERC20 public immutable token;

    // Push Chain Donut testnet chain ID constant
    string public constant PUSH_CHAIN_ID = "push-donut";

    // Events
    event Claimed(
        address indexed recipient,
        string chainNamespace,
        string chainId,
        uint256 amount
    );
    event MerkleRootUpdated(bytes32 newRoot);

    /**
     * @dev Constructor
     * @param _token The ERC20 token to be airdropped
     * @param _merkleRoot The initial Merkle root for the airdrop
     */
    constructor(IERC20 _token, bytes32 _merkleRoot) Ownable(msg.sender) {
        token = _token;
        merkleRoot = _merkleRoot;
    }

    /**
     * @dev Claim tokens using a Merkle proof
     * @param proof The Merkle proof proving inclusion in the airdrop
     * @param amount The amount of tokens to claim
     * @param chainNamespace The origin chain namespace (e.g., "eip155", "solana", "push")
     * @param chainId The origin chain ID (e.g., "11155111" for Sepolia, "push-donut" for Push)
     * @notice The claim is bound to the caller's origin chain to prevent cross-chain spoofing
     */
    function claim(
        bytes32[] calldata proof,
        uint256 amount,
        string calldata chainNamespace,
        string calldata chainId
    ) external nonReentrant {
        address caller = msg.sender;

        // Get origin chain information from UEAFactory for verification
        (UniversalAccountId memory account, bool isUEA) = IUEAFactory(
            UEA_FACTORY
        ).getOriginForUEA(caller);

        address recipientAddress;

        if (isUEA) {
            // For UEA accounts, verify the provided chain info matches the origin
            require(
                keccak256(abi.encodePacked(chainNamespace)) ==
                    keccak256(abi.encodePacked(account.chainNamespace)) &&
                    keccak256(abi.encodePacked(chainId)) ==
                    keccak256(abi.encodePacked(account.chainId)),
                "Provided chain info does not match UEA origin"
            );
            // Convert owner bytes to address for leaf computation
            // If owner is 20 bytes (EVM), cast directly; otherwise derive address from keccak256(owner)
            if (account.owner.length == 20) {
                recipientAddress = address(bytes20(account.owner));
            } else {
                recipientAddress = address(
                    uint160(uint256(keccak256(account.owner)))
                );
            }
        } else {
            // For non-UEA accounts (could be native Push Chain or direct connections)
            // Allow claiming from any chain - the Merkle proof will verify eligibility
            recipientAddress = caller;
        }

        // Generate claimId to prevent double claims for the same (address, chainNamespace, chainId) tuple
        bytes32 claimId = keccak256(
            abi.encodePacked(recipientAddress, chainNamespace, chainId)
        );
        require(!claimed[claimId], "Already claimed for this origin chain");

        // Compute the leaf as per specification: keccak256(abi.encodePacked(recipientOnPush, chainNamespace, chainId, amount))
        bytes32 leaf = keccak256(
            abi.encodePacked(recipientAddress, chainNamespace, chainId, amount)
        );

        // Verify the Merkle proof
        require(
            MerkleProof.verify(proof, merkleRoot, leaf),
            "Invalid Merkle proof"
        );

        // Mark as claimed and transfer tokens
        claimed[claimId] = true;
        require(
            token.transfer(recipientAddress, amount),
            "Token transfer failed"
        );

        emit Claimed(recipientAddress, chainNamespace, chainId, amount);
    }

    /**
     * @dev Update the Merkle root (only owner)
     * @param newRoot The new Merkle root
     * @notice This allows updating the airdrop with new recipients
     */
    function setMerkleRoot(bytes32 newRoot) external onlyOwner {
        merkleRoot = newRoot;
        emit MerkleRootUpdated(newRoot);
    }

    /**
     * @dev Recover ERC20 tokens (only owner)
     * @param tokenAddress The address of the token to recover
     * @param amount The amount to recover
     * @notice Allows the owner to recover mistakenly sent tokens
     */
    function recoverERC20(
        address tokenAddress,
        uint256 amount
    ) external onlyOwner {
        require(tokenAddress != address(token), "Cannot recover airdrop token");
        IERC20(tokenAddress).transfer(owner(), amount);
    }
}
```

**Key features of the UniversalAirdrop contract:**

- **Merkle Proof Verification**: Uses OpenZeppelin's `MerkleProof.verify()` to validate inclusion proofs
- **Universal Support**: Accepts any recipient address format (the proof generation handles the conversion)
- **Reentrancy Protection**: Uses `ReentrancyGuard` to prevent reentrancy attacks
- **Claim Tracking**: Maps claim IDs (address + origin chain) to prevent double claims per recipient per origin chain
- **Owner Controls**: Allows updating the Merkle root for future airdrop rounds


</TabItem>
<TabItem value='Generate Merkle Tree' label='Generate Merkle Tree'>

<br />

In this part, we'll create a Merkle proof generator that produces cryptographic proofs for a universal airdrop system. This generator will create a Merkle tree from recipient data and generate proofs that can be verified on-chain.

### 1.1. Set up the Merkle proof generator

Create the project directory and install the required dependencies:

```bash
mkdir merkle-proof-generator
cd merkle-proof-generator
npm init -y
tsc --init
npm install bs58 merkletreejs viem
npm i -D @types/node
```

The dependencies you'll need:

- `@openzeppelin/merkle-tree`: Core library for building Merkle trees with cryptographic hashing
- `viem`: Ethereum library providing `keccak256` hashing and ABI encoding utilities
- `bs58`: Base58 encoding/decoding library for Solana addresses

<NodeJSVirtualIDE repo={{title: "Open in Github", url: "https://github.com/pushchain/push-chain-examples/tree/main/core-sdk-functions/initialize-push-chain-client"}}>

  {`
  import { keccak256 } from 'viem';
import { makeMerkleTree, getProof } from '@openzeppelin/merkle-tree/dist/core.js';
import bs58 from 'bs58';

// Hardcoded airdrop data (previously read from data/airdrop.json)
const AIRDROP_ENTRIES = [
  {
    recipient: '0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9',
    chainNamespace: 'eip155',
    chainId: '11155111',
    amount: '10000000000000000000',
  },
];

/**
 * Generate a leaf hash matching the Solidity contract
 * leaf = keccak256(abi.encodePacked(recipientOnPush, chainNamespace, chainId, amount))
 */
function generateLeaf(entry) {
  const { recipient, chainNamespace, chainId, amount } = entry;

  // Normalize recipient address:
  // - If hex 0x address (length 42), parse as 20-byte address
  // - Else treat as base58 (e.g., Solana), hash bytes and take last 20 bytes
  let recipientAddressHex;
  if (recipient.startsWith('0x')) {
    const addr = recipient.toLowerCase();
    const addressBytes = addr.slice(2).padStart(40, '0');
    recipientAddressHex = addressBytes;
  } else {
    const raw = Buffer.from(bs58.decode(recipient));
    const hashed = Buffer.from(keccak256('0x' + raw.toString('hex')).slice(2), 'hex');
    const last20 = hashed.slice(-20);
    recipientAddressHex = last20.toString('hex');
  }

  const namespaceBytes = Buffer.from(chainNamespace, 'utf8');
  const chainIdBytes = Buffer.from(chainId, 'utf8');
  const amountBytes = Buffer.alloc(32);
  amountBytes.writeBigUInt64BE(BigInt(amount), 24);

  const packedBytes = Buffer.concat([
    Buffer.from(recipientAddressHex, 'hex'),
    namespaceBytes,
    chainIdBytes,
    amountBytes,
  ]);

  return keccak256('0x' + packedBytes.toString('hex'));
}

/**
 * Build Merkle tree from airdrop entries
 */
function buildMerkleTree(entries) {
  // Generate leaves
  const leaves = entries.map((entry) => generateLeaf(entry));

  // Create Merkle tree with sorted node hashing (default)
  const tree = makeMerkleTree(leaves);
  const merkleRoot = tree[0];

  // Generate proofs for each entry
  const entriesWithProofs = entries.map((entry, index) => {
    const leafIndex = tree.length - 1 - index;
    const proof = getProof(tree, leafIndex);

    return {
      ...entry,
      leaf: leaves[index],
      proof,
    };
  });

  return {
    merkleRoot,
    entries: entriesWithProofs,
  };
}

/**
 * Print summary of the airdrop data
 */
function printSummary(treeData) {
  const { entries, merkleRoot } = treeData;

  console.log('🌳 Universal Airdrop Merkle Tree Summary');
  console.log('=====================================');
  console.log('📁 Merkle Root: ' + merkleRoot);
  console.log('👥 Total Recipients: ' + entries.length);

  // Calculate totals per chain namespace
  const chainStats = entries.reduce((acc, entry) => {
    const key = entry.chainNamespace + ':' + entry.chainId;
    if (!acc[key]) {
      acc[key] = { count: 0, totalAmount: BigInt(0) };
    }
    acc[key].count += 1;
    acc[key].totalAmount += BigInt(entry.amount);
    return acc;
  }, {});

  console.log('\n📊 Per-Chain Breakdown:');
  Object.entries(chainStats).forEach(([chain, stats]) => {
    console.log('  ' + chain + ': ' + stats.count + ' recipients, ' + stats.totalAmount.toString() + ' tokens');
  });

  // Calculate total amount
  const totalAmount = entries.reduce((sum, entry) => sum + BigInt(entry.amount), BigInt(0));
  console.log('\n💰 Total Airdrop Amount: ' + totalAmount.toString() + ' tokens');
}

// Main execution
async function main() {
  // Use hardcoded airdrop entries
  const entries = AIRDROP_ENTRIES;

  // Validate entries
  for (const entry of entries) {
    const isHex = entry.recipient.startsWith('0x') && entry.recipient.length === 42;
    const isBase58 = !entry.recipient.startsWith('0x');
    if (!isHex && !isBase58) {
      throw new Error('Invalid recipient: ' + entry.recipient + ' (must be 0x-address or base58)');
    }
    if (!entry.chainNamespace || !entry.chainId) {
      throw new Error('Missing chain info for ' + entry.recipient);
    }
    if (isNaN(parseInt(entry.amount)) || BigInt(entry.amount) <= 0) {
      throw new Error('Invalid amount for ' + entry.recipient + ': ' + entry.amount);
    }
  }

  console.log('🔨 Building Merkle tree for ' + entries.length + ' recipients...');

  // Build Merkle tree
  const treeData = buildMerkleTree(entries);

  // Output Merkle tree data to console instead of writing to a file
  console.log(JSON.stringify(treeData, null, 2));
  console.log('✅ Merkle tree built successfully!');

  // Print summary
  printSummary(treeData);
}

await main().catch(console.error);

  `}

</NodeJSVirtualIDE>

Each entry in the array represents a recipient with:

- `recipient`: Wallet address (format varies by blockchain)
- `chainNamespace`: Blockchain type ("eip155", "solana", "push", etc.)
- `chainId`: Specific chain identifier within that namespace
- `amount`: Token amount in smallest units (as string to avoid precision issues)


#### How the Merkle proof works:

The proof allows anyone to verify that a specific recipient is included in the airdrop without revealing the entire recipient list. The smart contract can verify the proof by:

1. Recalculating the leaf hash from the recipient's data
2. Using the provided proof hashes to reconstruct the path to the root
3. Comparing the reconstructed root with the stored `merkleRoot`

> ✅ **Next steps**: You'll use the `merkleRoot` when deploying the UniversalAirdrop contract, and the frontend will use each recipient's `proof` array to submit claims on-chain.

</TabItem>
</Tabs>

The UI will use this file to interact with the deployed contracts and validate airdrop claims.

## Conclusion

You generated **Merkle proofs** from an airdrop list, deployed a **Universal Merkle‑verified airdrop contract** to **Push Chain Donut Testnet**, and added a **claim UI**. With this universal airdrop system, users from different chains can claim their tokens seamlessly using Push Chain's Universal External Accounts (UEA) system.

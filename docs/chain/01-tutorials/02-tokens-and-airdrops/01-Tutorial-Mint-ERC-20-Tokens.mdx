---
id: docs-chain-tutorials-mint-erc-20-tokens
title: Mint Universal ERC-20 Tokens
hide_title: false
slug: ./tutorial-mint-erc-20-tokens
displayed_sidebar: pushChainSidebar
sidebar_position: 3
image: '/assets/docs/previews/docs_chain_tutorials_mint_erc_20_tokens--mint_universal_erc-20_tokens_(via_push-swap).png'
---

<head>
  <title>Mint Universal ERC-20 Tokens | Tutorials | Push Chain Docs</title>
</head>

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {
  ModalContainer,
  ModalSmall,
  ModalWrapper,
} from '@site/src/css/SharedStyling';
import IFrameModal from '@site/src/components/IFrameModal/IFrameModal';
import NodeJSVirtualIDE from '@site/src/components/NodeJSVirtualIDE/NodeJSVirtualIDE';

{/* Content Start */}

This tutorial shows how to let users on any chain mint a universal ERC-20 called `$AIRDROP` by leveraging Push Universal Transactions plus a Uniswap v3 pool on Push Chain. Users “mint” by swapping `$WPUSH` (Wrapped Push Token) to `$AIRDROP` through the `$AIRDROP/$WPUSH` pool; the universal wallet abstracts cross-chain execution.

What you’ll do:

1. Deploy a standard ERC-20 `$AIRDROP` token on Push Chain
2. Create a `$AIRDROP/$WPUSH` pool and add liquidity
3. Test a swap programmatically
4. Build a frontend UI that lets users mint `$WPUSH` and swap between `$WPUSH` and `$AIRDROP`

## Tutorial Overview

This tutorial is divided into five main parts:

### Part 1: Deploy ERC-20 Token to Push Chain

Set up Hardhat, write and deploy an `$AIRDROP` ERC-20 token contract to Push Chain testnet.

### Part 2: Mint $WPUSH Tokens

Create a script to mint `$WPUSH` tokens (wrapped Push Chain tokens) needed for liquidity pools.

### Part 3: Create Liquidity Pool

Set up a Uniswap V3 `$AIRDROP/$WPUSH` pool and add initial liquidity for token swapping.

### Part 4: Test Token Swaps

Build a script to programmatically swap `$WPUSH` for `$AIRDROP` tokens through the pool.

### Part 5: Build Frontend UI
Create a React app with Push Universal Wallet integration that allows users to mint `$WPUSH` by depositing `$PC` and swap between `$WPUSH` and `$AIRDROP` using the Uniswap v3 router on Push Chain.

## Part 1: Deploying a standard ERC-20 token to Push Chain’s testnet with Hardhat

> **Note:** For a deeper dive on how to configure Hardhat to Push Chain, please refer to this page [Configure Hardhat](/docs/chain/02-setup/02-smart-contract-environment/03-Configure-Hardhat.mdx)

### 1.1. Setting up Hardhat

First, let’s set up a new Hardhat project.

```bash
# Create the project directory
mkdir airdrop-token
cd airdrop-token

# Initialize a new Node.js project
npm init -y

# Install Hardhat and its toolbox
npm install --save-dev hardhat@2.26.3 @nomicfoundation/hardhat-toolbox@6.1.0

# Initialize Hardhat (select the options "Hardhat 2" then "Create a TypeScript project")
npx hardhat init
```

Now, install required dependencies:

```bash
# Install dotenv for environment variable management
npm install dotenv

# Install OpenZeppelin contracts library
npm install @openzeppelin/contracts
```

- `dotenv`: Allows us to load environment variables from a .env file, keeping sensitive information like private keys secure
- `@openzeppelin/contracts`: Provides battle-tested smart contract implementations including ERC-20

### 1.2. Configuring Hardhat (`hardhat.config.ts`)

Update your `hardhat.config.ts` to include network configurations and compiler settings:

```typescript
import { HardhatUserConfig } from 'hardhat/config';
import '@nomicfoundation/hardhat-toolbox';
import { config as dotenvConfig } from 'dotenv';

// Load environment variables
dotenvConfig();

const config: HardhatUserConfig = {
  solidity: {
    version: '0.8.22',
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
      viaIR: true,
    },
  },
  networks: {
    pushDonut: {
      url: 'https://evm.rpc-testnet-donut-node1.push.org/',
      accounts: process.env.PRIVATE_KEY
        ? [
            process.env.PRIVATE_KEY.startsWith('0x')
              ? process.env.PRIVATE_KEY
              : `0x${process.env.PRIVATE_KEY}`,
          ]
        : [],
      chainId: 42101,
    },
  },
  paths: {
    sources: './contracts',
    tests: './test',
    cache: './cache',
    artifacts: './artifacts',
  },
};

export default config;
```

**Key configuration details:**

- **Solidity Compiler**: Version 0.8.22 with optimization enabled (200 runs) and viaIR enabled for better gas efficiency
- **Networks**:
  - `pushDonut`: Push Chain Donut Testnet with environment-based private key
- **Paths**: Standard Hardhat directory structure

### 1.4. Create the Airdrop Token Contract

Create a new file `contracts/AirdropToken.sol` with the following content:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract AirdropToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1_000_000 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
```

### 1.5. Compiling the Contract

Compile the contract with:

```bash
npx hardhat compile
```

### 1.6. Deploying the Airdrop Token Contract to Push Chain

Create a `.env` file in the root directory and add your private key that you will use to deploy the contract to Push Chain. If you need `$PC` tokens to deploy the contract, you can get them from the [Push Chain Faucet](https://faucet.push.org/).

Add the following to the `.env` file:

```bash
PRIVATE_KEY=0xyour_private_key
```

Then create a deployment script at `scripts/deploy.ts` that will also write the deployed address to a file called `deployed-addresses.json` for later use:

```typescript
import { config } from 'dotenv';
import { ethers } from 'hardhat';
import hre from 'hardhat';
import { writeFileSync } from 'fs';
import { AirdropToken__factory, AirdropToken } from '../typechain-types';

// Load environment variables
config();

async function main() {
  console.log('🚀 Starting deployment...');

  // Debug: Check environment and network
  console.log('🔍 Checking environment...');
  console.log('📝 PRIVATE_KEY exists:', !!process.env.PRIVATE_KEY);

  // Get the deployer account
  const signers = await ethers.getSigners();
  console.log('👥 Number of signers:', signers.length);

  console.log('Current network:', hre.network.name);

  if (signers.length === 0) {
    console.log('❌ Current network:', hre.network.name);
    console.log('❌ Network config:', hre.network.config);
    throw new Error(
      'No accounts available. Please check your PRIVATE_KEY in .env file and network configuration.'
    );
  }

  const [deployer] = signers;
  console.log('📝 Deploying contracts with account:', deployer.address);
  console.log(
    '💰 Account balance:',
    ethers.formatEther(await ethers.provider.getBalance(deployer.address))
  );

  // Deploy AirdropToken (ERC20)
  console.log('\n📄 Deploying AirdropToken...');
  const tokenFactory = new AirdropToken__factory(deployer);
  const token: AirdropToken = await tokenFactory.deploy(
    'AirdropToken',
    'AIRDROP'
  );
  await token.waitForDeployment();
  const tokenAddress = await token.getAddress();
  console.log('✅ AirdropToken deployed to:', tokenAddress);

  // Write deployed address to file for setup-pool.ts to use
  const deployedData = {
    AIRDROP_ADDR: tokenAddress,
    network: hre.network.name,
  };
  writeFileSync(
    './deployed-addresses.json',
    JSON.stringify(deployedData, null, 2)
  );
  console.log('📝 Deployed address saved to: ./deployed-addresses.json');

  // Read token details
  const [name, symbol, decimals] = await Promise.all([
    token.name(),
    token.symbol(),
    token.decimals(),
  ]);

  const [totalSupply, deployerBalance] = await Promise.all([
    token.totalSupply(),
    token.balanceOf(deployer.address),
  ]);

  console.log(`🔎 Token: ${name} (${symbol}), Decimals: ${decimals}`);
  console.log(`🏦 Total supply: ${ethers.formatEther(totalSupply)} ${symbol}`);
  console.log(
    `👤 Deployer balance: ${ethers.formatEther(deployerBalance)} ${symbol}`
  );

  console.log('\n🎉 Deployment completed successfully!');
  console.log('\n📋 Summary:');
  console.log(`   Token Contract: ${tokenAddress}`);
  console.log(`   Token Name: ${name}`);
  console.log(`   Token Symbol: ${symbol}`);
  console.log(`   Total Supply: ${ethers.formatEther(totalSupply)} ${symbol}`);
}

// Handle errors
main().catch((error) => {
  console.error('❌ Deployment failed:', error);
  process.exitCode = 1;
});
```

Now, deploy the Airdrop Token Contract to Push Chain:

```bash
npx hardhat run scripts/deploy.js --network pushDonut
```

Example output:

```bash
🚀 Starting deployment...
🔍 Checking environment...
📝 PRIVATE_KEY exists: true
👥 Number of signers: 1
Current network: pushDonut
📝 Deploying contracts with account: 0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9
💰 Account balance: 9876.865290171749999941

📄 Deploying AirdropToken...
✅ AirdropToken deployed to: 0x64C91bcb3E45c29BBd75CBC344f2F495c37aDD47
📝 Deployed address saved to: ./deployed-addresses.json
🔎 Token: AirdropToken (AIRDROP), Decimals: 18
🏦 Total supply: 1000000.0 AIRDROP
👤 Deployer balance: 1000000.0 AIRDROP

🎉 Deployment completed successfully!

📋 Summary:
   Token Contract: 0x64C91bcb3E45c29BBd75CBC344f2F495c37aDD47
   Token Name: AirdropToken
   Token Symbol: AIRDROP
   Total Supply: 1000000.0 AIRDROP
```

## Part 2: Minting `$WPUSH` tokens

`WPUSH` is the wrapped version of the native Push Chain gas token (`$PC`). To mint `WPUSH` tokens, you deposit `$PC` into the `WPUSH` contract. This section provides a Node.js script to mint `WPUSH` tokens programmatically.

Create `scripts/mint-wpush.ts` to deposit `$PC` into the `WPUSH` contract and mint `WPUSH` tokens:

```typescript
import { ethers } from 'ethers';
import * as dotenv from 'dotenv';

dotenv.config();

// Contract addresses
const CONTRACTS = {
  wpush: '0x2c7EbF633ffC84ea67eB6C8B232DC5f42970B818',
} as const;

// WPUSH ABI
const WPUSH_ABI = [
  'function balanceOf(address) view returns (uint256)',
  'function deposit() payable',
  'function transfer(address,uint256) returns (bool)',
] as const;

const PUSH_RPC_URL = 'https://evm.rpc-testnet-donut-node1.push.org/';
const PRIVATE_KEY: string | undefined = process.env.PRIVATE_KEY;

// Configuration - modify these values as needed
const AMOUNT_TO_MINT = '5'; // Amount of WPUSH to mint

// Types
interface MintResult {
  targetAddress: string;
  amount: string;
  depositTx: string;
}

// Helper functions
function getSigner(): ethers.Wallet {
  if (!PRIVATE_KEY) {
    throw new Error('PRIVATE_KEY is not configured');
  }
  const provider = new ethers.JsonRpcProvider(PUSH_RPC_URL);
  return new ethers.Wallet(PRIVATE_KEY, provider);
}

function getWpushContract(): ethers.Contract {
  const signer = getSigner();
  return new ethers.Contract(CONTRACTS.wpush, WPUSH_ABI, signer);
}

// Main minting function
async function mintWpushToAddress(
  targetAddress: string,
  amount: string
): Promise<MintResult> {
  // Validate inputs
  if (!ethers.isAddress(targetAddress)) {
    throw new Error(`Invalid Ethereum address: ${targetAddress}`);
  }

  const amountWei = ethers.parseUnits(amount.toString(), 18);
  const signer = getSigner();
  const wpushContract = getWpushContract();

  // Check balance
  const signerBalance = await signer.provider!.getBalance(signer.address);
  if (signerBalance < amountWei) {
    throw new Error(
      `Insufficient PUSH balance. Required: ${ethers.formatUnits(amountWei)}, Available: ${ethers.formatUnits(
        signerBalance
      )}`
    );
  }

  // Deposit PUSH to get WPUSH
  const depositTx = await wpushContract.deposit({ value: amountWei });
  await depositTx.wait();

  return {
    targetAddress,
    amount,
    depositTx: depositTx.hash,
  };
}

// Main function
async function main(): Promise<void> {
  const TARGET_ADDRESS = getSigner().address;
  console.log(`🚀 Minting ${AMOUNT_TO_MINT} WPUSH to ${TARGET_ADDRESS}\n`);

  try {
    const result = await mintWpushToAddress(TARGET_ADDRESS, AMOUNT_TO_MINT);
    console.log(
      `✅ Successfully minted ${AMOUNT_TO_MINT} WPUSH to ${TARGET_ADDRESS}`
    );
    console.log(`📋 Deposit TX: ${result.depositTx}`);

    // Check final WPUSH balance
    const wpushContract = getWpushContract();
    const finalBalance = await wpushContract.balanceOf(TARGET_ADDRESS);
    const formattedBalance = ethers.formatUnits(finalBalance, 18);
    console.log(`💰 Final WPUSH balance: ${formattedBalance} WPUSH`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ Error:', errorMessage);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('Unhandled error:', error);
  process.exit(1);
});
```

Run:

```bash
npx ts-node scripts/mint-wpush.ts
```

Example output:

```bash
🚀 Minting 1 WPUSH to 0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9

✅ Successfully minted 1 WPUSH to 0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9
📋 Deposit TX: 0xd8a62e24f9157950d46b5d99b94b693e09064147078fe7cace95093de4da8e3a
```

## Part 3: Create `$AIRDROP/$WPUSH` Pool and Add Liquidity

For this part, we'll use the `ethers` library to interact with the Push Chain network. Install `ethers` by running:

```bash
npm install ethers
```

Then create `scripts/create-pool.ts` to create and initialize the pool and add liquidity via PositionManager:

<NodeJSVirtualIDE>

{`
  import { ethers } from 'ethers';
  import \* as readline from 'node:readline/promises';

    // --- Constants (update if different) ---
    const RPC = 'https://evm.rpc-testnet-donut-node1.push.org/';
    const FACTORY = '0xF02DA51d1Ef1c593a95f5C97d7BdFc49fbaBbaA5';
    const POSITION_MANAGER = '0xf90F08fD301190Cd34CC9eFc5A76351e95051670';
    // Use the deployed WPUSH used by other scripts in this repo
    const WPUSH = '0x2c7EbF633ffC84ea67eB6C8B232DC5f42970B818';
    const AIRDROP = '0x59cf8bF716157ec7f7d7d37f8Bcb0EeacE826c7B';

    // Enable User Input
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    // Using in-file constant for AIRDROP address
    console.log('📝 Using AIRDROP address:', AIRDROP);

    // --- Minimal ABIs ---
    const ABI = {
      factory: [
        'function getPool(address,address,uint24) view returns (address)',
        'function createPool(address,address,uint24) returns (address)',
        'event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool)',
      ],
      pool: [
        'function initialize(uint160 sqrtPriceX96)',
        'function fee() view returns (uint24)',
        'function token0() view returns (address)',
        'function token1() view returns (address)',
        'function slot0() view returns (uint160 sqrtPriceX96, int24 tick, uint16, uint16, uint16, uint8, bool)',
      ],
      erc20: [
        'function symbol() view returns (string)',
        'function decimals() view returns (uint8)',
        'function balanceOf(address) view returns (uint256)',
        'function allowance(address,address) view returns (uint256)',
        'function approve(address,uint256) returns (bool)',
      ],
      wpush: [
        'function deposit() payable',
        'function balanceOf(address) view returns (uint256)',
        'function decimals() view returns (uint8)',
        'function symbol() view returns (string)',
      ],
      positionManager: [
        'function mint((address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline)) returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)',
      ],
    };

    

    // Integer helpers using bigint
    function pow10(exponent) {
      let result = 1n;
      for (let i = 0; i < exponent; i++) result *= 10n;
      return result;
    }

    function sqrtRatioFloor(numerator, denominator) {
      if (denominator <= 0n) throw new Error('Denominator must be positive');
      // Find integer p = floor( sqrt(numerator / denominator) )
      // by searching p such that p^2 * denominator <= numerator
      let low = 0n;
      let high = 1n;
      while (high * high * denominator <= numerator) {
        high <<= 1n;
      }
      while (low + 1n < high) {
        const mid = (low + high) >> 1n;
        if (mid * mid * denominator <= numerator) {
          low = mid;
        } else {
          high = mid;
        }
      }
      return low;
    }

    // Precise sqrtPriceX96 calculator matching Uniswap encodePriceSqrt (no floating point)
    function sqrtPriceX96FromHumanRatio(
      priceRatio,
      token0Decimals,
      token1Decimals
    ) {
      const s = priceRatio.toString();
      const SCALE = 36; // high precision scale for decimal parsing
      const ratioScaled = ethers.parseUnits(s, SCALE);
      const Q192 = 1n << 192n;
      const numerator = ratioScaled * pow10(token1Decimals) * Q192;
      const denominator = pow10(token0Decimals) * pow10(SCALE);
      return sqrtRatioFloor(numerator, denominator);
    }

    function sortTokens(a, b) {
      return a.toLowerCase() < b.toLowerCase() ? [a, b] : [b, a];
    }

    async function safeApprove(token, spender, amount, owner) {
      const current = await token.allowance(owner, spender);
      if (current >= amount) return;
      const tx = await token.approve(spender, ethers.MaxUint256);
      await tx.wait();
    }

    async function main() {
      if (!AIRDROP) throw new Error('AIRDROP address not found. Please run deploy.ts first.');

      const provider = new ethers.JsonRpcProvider(RPC);
      const ephemeral = ethers.Wallet.createRandom();
      const wallet = ephemeral.connect(provider);

      console.log('🔑 Ephemeral wallet address:', wallet.address);
      await rl.question(':::prompt:::Please send funds to: ' + wallet.address + ' on Push Testnet Donut to continue.');

      const factory = new ethers.Contract(FACTORY, ABI.factory, wallet);
      const positionManager = new ethers.Contract(POSITION_MANAGER, ABI.positionManager, wallet);

      const air = new ethers.Contract(AIRDROP, ABI.erc20, wallet);
      const wpush = new ethers.Contract(WPUSH, ABI.wpush, wallet);

      // 1) Ensure WPUSH balance (wrap 5 $PC)
      const wrapAmount = ethers.parseUnits('5', 18);
      const bal = await wpush.balanceOf(wallet.address);
      const nativeBefore = await provider.getBalance(wallet.address);
      console.log('💰 Native PC balance:', ethers.formatUnits(nativeBefore, 18));
      console.log('💧 WPUSH balance:', ethers.formatUnits(bal, 18));
      if (bal < wrapAmount) {
        const needed = wrapAmount - bal;
        let nativeBal = nativeBefore;
        while (nativeBal < needed) {
          console.log(
            '⏳ Insufficient native PC. Needed:',
            ethers.formatUnits(needed, 18),
            'PC; Have:',
            ethers.formatUnits(nativeBal, 18)
          );
          await rl.question(':::prompt:::Please send more native PC (for wrapping) and press Enter to retry.');
          nativeBal = await provider.getBalance(wallet.address);
          console.log('💰 Native PC balance:', ethers.formatUnits(nativeBal, 18));
        }
        console.log('Depositing native PC to get WPUSH...');
        const tx = await wpush.deposit({ value: needed });
        await tx.wait();
      }

      // 2) Create or fetch pool: AIRDROP/WPUSH @ 0.3%
      const fee = 3000;
      const [token0, token1] = sortTokens(AIRDROP, WPUSH);

      let pool = await factory.getPool(token0, token1, fee);
      if (pool === ethers.ZeroAddress) {
        console.log('Creating pool...');
        const tx = await factory.createPool(token0, token1, fee);
        const receipt = await tx.wait();

        // ethers v6 does not populate 'events'; parse logs manually
        let poolAddr;
        for (const log of receipt.logs) {
          if (log.address?.toLowerCase() !== FACTORY.toLowerCase()) continue;
          try {
            const parsed = factory.interface.parseLog({
              data: log.data,
              topics: [...log.topics],
            });
            if (parsed?.name === 'PoolCreated') {
              poolAddr = parsed.args.pool;
              break;
            }
          } catch {}
        }

        // Fallback: query factory for pool address after tx mined
        pool = poolAddr ?? (await factory.getPool(token0, token1, fee));
        if (!pool || pool === ethers.ZeroAddress) throw new Error('Pool not created');
        console.log('Pool:', pool);

        // Initialize with a target price. Example: 1 AIRDROP = 0.001 PC
        // Convert to token1/token0 ratio depending on sort order
        const token0Contract = new ethers.Contract(token0, ABI.erc20, wallet);
        const token1Contract = new ethers.Contract(token1, ABI.erc20, wallet);

        const dec0 = await token0Contract.decimals();
        const dec1 = await token1Contract.decimals();

        const inputSymbol0 = await air.symbol();
        const inputSymbol1 = await wpush.symbol();

        const sortedSymbol0 = await token0Contract.symbol();
        const sortedSymbol1 = await token1Contract.symbol();

        const humanRatio = 0.001; // 1 AIRDROP = 0.001 PC
        const actualRatio =
          inputSymbol0 === sortedSymbol1 && inputSymbol1 === sortedSymbol0 ? 1 / humanRatio : humanRatio;

        const sqrtP = sqrtPriceX96FromHumanRatio(actualRatio, dec0, dec1);
        const poolCtr = new ethers.Contract(pool, ABI.pool, wallet);
        await (await poolCtr.initialize(sqrtP)).wait();
        console.log('Pool initialized');
      } else {
        console.log('Pool exists:', pool);
      }

      // Skipping persistence of pool address to file; using in-file constants only

      // 3) Add liquidity (wide range)
      const poolCtr = new ethers.Contract(pool, ABI.pool, wallet);
      const poolFee = Number(await poolCtr.fee());

      const t0 = await poolCtr.token0();
      const t1 = await poolCtr.token1();

      const tok0 = new ethers.Contract(t0, ABI.erc20, wallet);
      const tok1 = new ethers.Contract(t1, ABI.erc20, wallet);
      const dec0 = await tok0.decimals();
      const dec1 = await tok1.decimals();

      // Target: deposit exactly 1 WPUSH and the equivalent AIRDROP by current price
      // Get current sqrtPriceX96 and derive base-unit ratio in integer math
      const slot0 = await poolCtr.slot0();
      const sqrtPriceX96 = slot0[0];
      const Q192 = 1n << 192n;
      const ratioNumerator = sqrtPriceX96 * sqrtPriceX96; // token1_base per token0_base numerator; denominator = Q192

      // Compute base-unit amounts for exactly 1 WPUSH
      const isWPUSH0 = t0.toLowerCase() === WPUSH.toLowerCase();
      const oneWPUSHBase = pow10(isWPUSH0 ? dec0 : dec1);

      let a0; // amount0Desired (base units of token0)
      let a1; // amount1Desired (base units of token1)

      if (isWPUSH0) {
        // token0 is WPUSH: amount0 = 1 WPUSH, amount1 = floor(amount0 * ratioNumerator / Q192)
        const amount0Base = oneWPUSHBase;
        const amount1Base = (amount0Base * ratioNumerator) / Q192;
        a0 = amount0Base;
        a1 = amount1Base;
      } else {
        // token1 is WPUSH: amount1 = 1 WPUSH, amount0 = floor(amount1 * Q192 / ratioNumerator)
        const amount1Base = oneWPUSHBase;
        const amount0Base = (amount1Base * Q192) / ratioNumerator;
        a0 = amount0Base;
        a1 = amount1Base;
      }

      // Ensure sufficient token balances for mint
      const [bal0Before, bal1Before] = await Promise.all([tok0.balanceOf(wallet.address), tok1.balanceOf(wallet.address)]);
      const sym0 = await tok0.symbol();
      const sym1 = await tok1.symbol();

      const need0 = bal0Before >= a0 ? 0n : a0 - bal0Before;
      const need1 = bal1Before >= a1 ? 0n : a1 - bal1Before;

      if (need0 > 0n || need1 > 0n) {
        console.log('🔎 Token balances before mint:');
        console.log('   ', sym0, ethers.formatUnits(bal0Before, dec0), '/', ethers.formatUnits(a0, dec0), 'required');
        console.log('   ', sym1, ethers.formatUnits(bal1Before, dec1), '/', ethers.formatUnits(a1, dec1), 'required');
      }

      // Auto-wrap for any missing WPUSH; otherwise prompt user to fund
      if (need0 > 0n) {
        if (t0.toLowerCase() === WPUSH.toLowerCase()) {
          let nativeBal = await provider.getBalance(wallet.address);
          while (nativeBal < need0) {
            console.log('⏳ Need more native PC to wrap into WPUSH. Missing:', ethers.formatUnits(need0 - nativeBal, 18));
            await rl.question(':::prompt:::Send more native PC and press Enter to retry.');
            nativeBal = await provider.getBalance(wallet.address);
          }
          console.log('Wrapping', ethers.formatUnits(need0, 18), 'PC into WPUSH...');
          await (await wpush.deposit({ value: need0 })).wait();
        } else {
          await rl.question(
            ':::prompt:::Please send ' +
              ethers.formatUnits(need0, dec0) +
              ' ' +
              sym0 +
              ' to ' +
              wallet.address +
              ' and press Enter.'
          );
        }
      }
      if (need1 > 0n) {
        if (t1.toLowerCase() === WPUSH.toLowerCase()) {
          let nativeBal = await provider.getBalance(wallet.address);
          while (nativeBal < need1) {
            console.log('⏳ Need more native PC to wrap into WPUSH. Missing:', ethers.formatUnits(need1 - nativeBal, 18));
            await rl.question(':::prompt:::Send more native PC and press Enter to retry.');
            nativeBal = await provider.getBalance(wallet.address);
          }
          console.log('Wrapping', ethers.formatUnits(need1, 18), 'PC into WPUSH...');
          await (await wpush.deposit({ value: need1 })).wait();
        } else {
          await rl.question(
            ':::prompt:::Please send ' +
              ethers.formatUnits(need1, dec1) +
              ' ' +
              sym1 +
              ' to ' +
              wallet.address +
              ' and press Enter.'
          );
        }
      }

      // Re-read balances and log
      const [bal0After, bal1After] = await Promise.all([tok0.balanceOf(wallet.address), tok1.balanceOf(wallet.address)]);
      console.log('✅ Token balances ready:');
      console.log('   ', sym0, ethers.formatUnits(bal0After, dec0));
      console.log('   ', sym1, ethers.formatUnits(bal1After, dec1));

      await safeApprove(tok0, POSITION_MANAGER, a0, wallet.address);
      await safeApprove(tok1, POSITION_MANAGER, a1, wallet.address);

      const poolFeeNum = Number(poolFee);
      const tickSpacing = poolFeeNum === 500 ? 10 : poolFeeNum === 3000 ? 60 : 200;
      const MIN_TICK = -887272;
      const MAX_TICK = 887272;
      const tickLower = Math.ceil(MIN_TICK / tickSpacing) * tickSpacing;
      const tickUpper = Math.floor(MAX_TICK / tickSpacing) * tickSpacing;

      const params = {
        token0: t0,
        token1: t1,
        fee: poolFee,
        tickLower,
        tickUpper,
        amount0Desired: a0,
        amount1Desired: a1,
        amount0Min: 0n,
        amount1Min: 0n,
        recipient: wallet.address,
        deadline: Math.floor(Date.now() / 1000) + 600,
      };

      const mintTx = await positionManager.mint(params);
      const rc = await mintTx.wait();
      console.log('Liquidity added. Tx:', rc?.hash);

      rl.close();
    }

    main().catch((e) => {
      console.error(e);
      process.exit(1);
    });
`}

</NodeJSVirtualIDE>

Run:

```bash
npx ts-node scripts/create-pool.ts
```

Example output:

```bash
📝 Using AIRDROP address from deployed-addresses.json: 0x64C91bcb3E45c29BBd75CBC344f2F495c37aDD47
Creating pool...
Pool: 0xEB1EA5EC91ad8917Ce33e73224087164CE573833
Pool initialized
Liquidity added. Tx: 0x944d81a58c4fb12a4eb72a7bcffd3b121a248334bcf3972a5614a91826ffc407
```

## Part 4: Building the Frontend UI

> **Note:** To learn more about how to integrate Push Universal Wallet, please refer to the [Integrate Push Universal Wallet](/docs/chain/04-ui-kit/01-Integrate-Push-Universal-Wallet.mdx) page.

### 4.1. Setting up Vite + React + TypeScript frontend

Create a new directory for the frontend and install the necessary dependencies:

```bash
npm create vite@latest my-react-ts-app -- --template react-ts
cd my-react-ts-app
npm install
```

### 4.2. Installing `@pushchain/ui-kit`

Install `@pushchain/ui-kit` in the frontend directory and `ethers` that we'll use to interact with the Push Chain network:

```bash
npm install @pushchain/ui-kit ethers
```

### 4.3. Setting up the Push Chain Wallet

To use the Push Universal Wallet in your application, you need to wrap your app with the `PushUniversalWalletProvider` component. This provider makes the wallet functionality available throughout your application.

Here's how to set it up in the `main.tsx` file:

```tsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import App from './App.tsx';
import { PushUniversalWalletProvider, PushUI } from '@pushchain/ui-kit';

const walletConfig = {
  network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET,
};

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <PushUniversalWalletProvider config={walletConfig}>
      <App />
    </PushUniversalWalletProvider>
  </StrictMode>
);
```

The `PushUniversalWalletProvider` component requires a `config` prop that specifies the network configuration. In this example, we're using the Push Chain testnet.

### 4.4. Set constants for addresses

Define your constants in code instead of fetching a JSON file:

```ts
const ADDRESSES = {
  AIRDROP_ADDR: '0x283E86104750B03Ed527Fa049193052778326122',
  POOL_ADDR: '0xf60F15211FaE940CD5a93d00359838AdD8e4cC54',
  network: 'pushDonut',
} as const;
```

### 4.5. Creating the Application Component

Open `App.tsx` and replace it with the following implementation. This app:

- Integrates the Push Universal Wallet
- Lets users deposit `$PC` and mint `$WPUSH` by calling `deposit()` on the `WPUSH` contract
- Swaps between `$WPUSH` and `$AIRDROP` using the Uniswap v3 router
- Displays balances and transaction hashes with explorer links

```jsx live
// customPropMinimized='true'
import { useEffect, useMemo, useState } from 'react';
import { ethers } from 'ethers';
import {
  PushUniversalAccountButton,
  usePushWalletContext,
  usePushChainClient,
  PushUI,
  PushUniversalWalletProvider,
} from '@pushchain/ui-kit';

function PushSwapExample() {
  // Network + Contracts (copied from backend script)
  const RPC = 'https://evm.rpc-testnet-donut-node1.push.org/';
  const FACTORY = '0xF02DA51d1Ef1c593a95f5C97d7BdFc49fbaBbaA5';
  const SWAP_ROUTER = '0x34B10a283c2331Afa2C7a6bb5FB961E01f218fa0';
  const WPUSH = '0x2c7EbF633ffC84ea67eB6C8B232DC5f42970B818';
  // Airdrop token address via constants (no JSON fetch)
  const ADDRESSES = {
    AIRDROP_ADDR: '0x283E86104750B03Ed527Fa049193052778326122',
    POOL_ADDR: '0xf60F15211FaE940CD5a93d00359838AdD8e4cC54',
    network: 'pushDonut',
  } as const;

  // Minimal ABIs
  const ERC20_ABI = [
    'function symbol() view returns (string)',
    'function decimals() view returns (uint8)',
    'function balanceOf(address) view returns (uint256)',
    'function allowance(address,address) view returns (uint256)',
    'function approve(address,uint256) returns (bool)',
  ];
  const FACTORY_ABI = ['function getPool(address,address,uint24) view returns (address)'];
  const ROUTER_ABI = [
    'function exactInputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) payable returns (uint256 amountOut)',
  ];
  const POOL_ABI = ['function fee() view returns (uint24)'];

  const provider = new ethers.JsonRpcProvider(RPC);

  const walletConfig = {
    network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET,
  };

  function Component() {
    const { connectionStatus, universalAccount } = usePushWalletContext();
    const { pushChainClient } = usePushChainClient();

    const [swapDirection, setSwapDirection] = useState('WPUSH_TO_AIRDROP');
    const [swapAmount, setSwapAmount] = useState('');
    const [isSwapLoading, setIsSwapLoading] = useState(false);
    const [isPoolLoading, setIsPoolLoading] = useState(false);
    const [swapTransactionHash, setSwapTransactionHash] = useState(null);
    const [error, setError] = useState(null);
    const [airdropTokenAddress, setAirdropTokenAddress] = useState(ADDRESSES.AIRDROP_ADDR);
    const [configError, setConfigError] = useState(null);
    // Mint WPUSH state
    const [mintAmount, setMintAmount] = useState('');
    const [isMintLoading, setIsMintLoading] = useState(false);
    const [mintTxnHash, setMintTxnHash] = useState(null);
    const [mintError, setMintError] = useState(null);

    const inputTokenAddress = useMemo(
      () => (airdropTokenAddress ? (swapDirection === 'AIRDROP_TO_WPUSH' ? airdropTokenAddress : WPUSH) : null),
      [swapDirection, airdropTokenAddress]
    );
    const outputTokenAddress = useMemo(
      () => (airdropTokenAddress ? (swapDirection === 'AIRDROP_TO_WPUSH' ? WPUSH : airdropTokenAddress) : null),
      [swapDirection, airdropTokenAddress]
    );

    const connectedAddress = universalAccount?.address ?? null;

    const [inputTokenDecimals, setInputTokenDecimals] = useState(18);
    const [outputTokenDecimals, setOutputTokenDecimals] = useState(18);
    const [inputTokenSymbol, setInputTokenSymbol] = useState('');
    const [outputTokenSymbol, setOutputTokenSymbol] = useState('');
    const [poolFee, setPoolFee] = useState(null);
    const [poolAddress, setPoolAddress] = useState(null);
    const [balanceAirdrop, setBalanceAirdrop] = useState('0');
    const [balanceWPUSH, setBalanceWPUSH] = useState('0');
    const [balanceAirdropRaw, setBalanceAirdropRaw] = useState(0n);
    const [balanceWPUSHRaw, setBalanceWPUSHRaw] = useState(0n);

    // Pretty print large decimal strings to at most 4 decimals
    const formatBalance4 = (value) => {
      if (!value) return '0';
      const [whole, frac = ''] = String(value).split('.');
      const wholePretty = Number(whole || '0').toLocaleString();
      const trimmed = frac.slice(0, 4).replace(/0+$/, '');
      return trimmed ? `${wholePretty}.${trimmed}` : wholePretty;
    };

    // Inline theme + reusable styles (light, neutral, readable)
    const colors = {
      background: 'transparent',
      surface: '#ffffff',
      surfaceMuted: '#f3f4f6',
      text: '#0f172a', // slate-900
      muted: '#6b7280', // gray-500
      primary: '#a855f7', // violet-500
      primary700: '#7c3aed', // violet-600
      border: '#e5e7eb', // gray-200
      danger: '#dc2626',
    };

    const styles = {
      page: {
        display: 'grid',
        placeItems: 'center',
        padding: '2rem',
        width: '100%',
      },
      container: {
        width: 460,
        margin: '0 auto',
        padding: 0,
        textAlign: 'left',
        color: colors.text,
        fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, sans-serif',
        lineHeight: 1.5,
      },
      title: { fontSize: '1.6rem', fontWeight: 700, margin: '0 0 1rem 0' },
      stackMd: { display: 'grid', gap: 12 },
      stackSm: { display: 'grid', gap: 8 },
      label: { fontSize: 12, color: colors.muted },
      input: {
        width: '100%',
        padding: '14px 16px',
        boxSizing: 'border-box',
        borderRadius: 12,
        border: `1px solid ${colors.border}`,
        background: colors.surfaceMuted,
        color: colors.text,
        outline: 'none',
        fontSize: 20,
      },
      button: {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '12px 16px',
        borderRadius: 12,
        border: `1px solid ${colors.border}`,
        background: colors.surface,
        color: colors.text,
        cursor: 'pointer',
        transition: 'all 120ms ease-out',
      },
      primaryBtn: {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        width: '100%',
        padding: '14px 16px',
        borderRadius: 12,
        border: 'none',
        background: colors.primary,
        color: '#ffffff',
        fontWeight: 700,
        cursor: 'pointer',
      },
      card: {
        background: colors.surface,
        border: `1px solid ${colors.border}`,
        borderRadius: 16,
        padding: 12,
        display: 'grid',
        gap: 10,
        boxShadow: '0 4px 16px rgba(15, 23, 42, 0.08)',
      },
      tokenRow: {
        background: colors.surfaceMuted,
        border: `1px solid ${colors.border}`,
        borderRadius: 12,
        padding: 12,
        display: 'grid',
        gap: 6,
      },
      rowHeader: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        color: colors.muted,
        fontSize: 12,
      },
      tokenTop: { display: 'flex', alignItems: 'center', justifyContent: 'space-between' },
      tokenBadge: {
        padding: '6px 10px',
        background: colors.surface,
        borderRadius: 10,
        border: `1px solid ${colors.border}`,
        fontSize: 12,
      },
      tokenInput: {
        width: '100%',
        border: 'none',
        background: 'transparent',
        color: colors.text,
        outline: 'none',
        fontSize: 28,
      },
      centerSwitch: { display: 'grid', placeItems: 'center', margin: '-6px 0' },
      switchBtn: {
        width: 36,
        height: 36,
        borderRadius: 18,
        border: `1px solid ${colors.border}`,
        background: colors.surface,
        color: colors.text,
        cursor: 'pointer',
      },
      radioRow: { display: 'flex', gap: 12 },
      segmented: { display: 'none' },
      segmentBtn: { display: 'none' },
      muted: { fontSize: 12, color: colors.muted },
      hashBox: { marginTop: 8, wordBreak: 'break-all' },
      link: {
        color: colors.primary,
        textDecoration: 'underline',
        fontWeight: 600,
      },
      error: { color: colors.danger },
      mintInline: { marginTop: 12, display: 'grid', gap: 8 },
      mintRow: { display: 'grid', gridTemplateColumns: '1fr auto', gap: 8 },
    };

    // Initialize from constants
    useEffect(() => {
      setAirdropTokenAddress(ADDRESSES.AIRDROP_ADDR);
      setPoolAddress(ADDRESSES.POOL_ADDR);
      setConfigError(null);
    }, []);

    useEffect(() => {
      let mounted = true;
      async function readTokenMeta(addr) {
        const c = new ethers.Contract(addr, ERC20_ABI, provider);
        const [dec, sym] = await Promise.all([c.decimals(), c.symbol()]);
        return { dec: Number(dec), sym: String(sym) };
      }
      async function findPool(a, b) {
        const [t0, t1] = a.toLowerCase() < b.toLowerCase() ? [a, b] : [b, a];
        const factory = new ethers.Contract(FACTORY, FACTORY_ABI, provider);
        const fees = [3000, 500, 10000];
        for (const fee of fees) {
          const addr = await factory.getPool(t0, t1, fee);
          if (addr && addr !== ethers.ZeroAddress) return { addr, fee };
        }
        return { addr: null, fee: null };
      }
      (async () => {
        try {
          setError(null);
          if (!inputTokenAddress || !outputTokenAddress) return;
          setIsPoolLoading(true);
          const [metaIn, metaOut] = await Promise.all([
            readTokenMeta(inputTokenAddress),
            readTokenMeta(outputTokenAddress),
          ]);
          let pool = { addr: null, fee: null };
          if (poolAddress && poolAddress !== ethers.ZeroAddress) {
            try {
              const pc = new ethers.Contract(poolAddress, POOL_ABI, provider);
              const fee = Number(await pc.fee());
              pool = { addr: poolAddress, fee };
            } catch {
              pool = { addr: poolAddress, fee: null };
            }
          } else {
            pool = await findPool(inputTokenAddress, outputTokenAddress);
          }
          if (!mounted) return;
          setInputTokenDecimals(metaIn.dec);
          setOutputTokenDecimals(metaOut.dec);
          setInputTokenSymbol(metaIn.sym);
          setOutputTokenSymbol(metaOut.sym);
          setPoolAddress(pool.addr);
          setPoolFee(pool.fee);
          setIsPoolLoading(false);
        } catch (e) {
          if (!mounted) return;
          const message = e instanceof Error ? e.message : String(e);
          setError(message || 'Failed to load token data');
          setIsPoolLoading(false);
        }
      })();
      return () => {
        mounted = false;
      };
    }, [inputTokenAddress, outputTokenAddress, poolAddress]);

    async function handleSwap() {
      try {
        setError(null);
        setSwapTransactionHash(null);
        if (!pushChainClient) throw new Error('Wallet not connected');
        if (!swapAmount) throw new Error('Enter amount');
        if (!poolFee || !poolAddress) throw new Error('No pool available for this pair');
        if (!inputTokenAddress || !outputTokenAddress) throw new Error('Tokens not ready');

        const recipient = pushChainClient.universal.account; // Source chain account that is mapped to the execution account
        console.log('recipient', recipient);

        if (!recipient) throw new Error('Could not resolve connected address');

        const amountIn = ethers.parseUnits(swapAmount, inputTokenDecimals);
        const balanceIn = inputTokenAddress === airdropTokenAddress ? balanceAirdropRaw : balanceWPUSHRaw;
        if (balanceIn < amountIn) throw new Error('Insufficient balance');

        // Approve router for tokenIn (use MaxUint to minimize subsequent approvals)
        const approveIface = new ethers.Interface(ERC20_ABI);
        const approveData = approveIface.encodeFunctionData('approve', [SWAP_ROUTER, ethers.MaxUint256]);
        const approveTx = await pushChainClient.universal.sendTransaction({
          to: inputTokenAddress,
          data: approveData,
          value: 0n,
        });
        // Optional: wait a moment for sequencing; wallet/provider may not expose wait here
        console.log('approve tx:', approveTx?.hash);

        // exactInputSingle params
        const params = {
          tokenIn: inputTokenAddress,
          tokenOut: outputTokenAddress,
          fee: poolFee,
          recipient,
          deadline: Math.floor(Date.now() / 1000) + 600,
          amountIn,
          amountOutMinimum: 0n,
          sqrtPriceLimitX96: 0n,
        };

        const routerIface = new ethers.Interface(ROUTER_ABI);
        const data = routerIface.encodeFunctionData('exactInputSingle', [params]);
        const swapTx = await pushChainClient.universal.sendTransaction({
          to: SWAP_ROUTER,
          data: data,
          value: 0n,
        });
        setSwapTransactionHash(swapTx?.hash ?? null);
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        setError(message || 'Swap failed');
      } finally {
        setIsSwapLoading(false);
      }
    }

    async function handleMintWpush() {
      try {
        setMintError(null);
        setMintTxnHash(null);
        if (!pushChainClient) throw new Error('Wallet not connected');
        if (!mintAmount) throw new Error('Enter amount');

        // We will call WPUSH.deposit() with value in PC (18 decimals)
        const valueWei = ethers.parseUnits(mintAmount, 18);
        const wpushIface = new ethers.Interface(['function deposit() payable']);
        const data = wpushIface.encodeFunctionData('deposit');

        const tx = await pushChainClient.universal.sendTransaction({
          to: WPUSH,
          data: data,
          value: valueWei,
        });
        setMintTxnHash(tx?.hash ?? null);
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        setMintError(message || 'Mint failed');
      } finally {
        setIsMintLoading(false);
      }
    }

    const isConnected = connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED;
    const parsedInputAmount = useMemo(() => {
      try {
        return swapAmount ? ethers.parseUnits(swapAmount, inputTokenDecimals) : null;
      } catch {
        return null;
      }
    }, [swapAmount, inputTokenDecimals]);
    const inputTokenBalanceRaw =
      inputTokenAddress === airdropTokenAddress
        ? balanceAirdropRaw
        : inputTokenAddress === WPUSH
        ? balanceWPUSHRaw
        : 0n;
    const hasSufficientBalance =
      !!swapAmount && parsedInputAmount !== null && inputTokenBalanceRaw >= parsedInputAmount;
    const canSwap =
      isConnected &&
      !isSwapLoading &&
      !!swapAmount &&
      !!poolFee &&
      !!connectedAddress &&
      !!inputTokenAddress &&
      !!outputTokenAddress &&
      hasSufficientBalance;

    // Balances
    useEffect(() => {
      let mounted = true;
      // const addr = connectedAddress;
      if (!pushChainClient) return;
      const addr = pushChainClient.universal.account; // Source chain account that is mapped to the execution account
      if (!addr) {
        console.log('No connected address');
        setBalanceAirdrop('0');
        setBalanceWPUSH('0');
        return;
      }
      (async () => {
        try {
          console.log('Loading balances');
          if (!airdropTokenAddress) return;
          console.log('Hello World', addr);
          console.log('Airdrop address', airdropTokenAddress);
          const [cAirdrop, cWpush] = [
            new ethers.Contract(airdropTokenAddress, ERC20_ABI, provider),
            new ethers.Contract(WPUSH, ERC20_ABI, provider),
          ];
          const [rawA, rawW] = await Promise.all([cAirdrop.balanceOf(addr), cWpush.balanceOf(addr)]);
          console.log('Balances loaded', rawA, rawW);
          setBalanceAirdropRaw(rawA);
          setBalanceWPUSHRaw(rawW);
          const airdropDecimals = inputTokenAddress === airdropTokenAddress ? inputTokenDecimals : outputTokenDecimals;
          const wpushDecimals = inputTokenAddress === WPUSH ? inputTokenDecimals : outputTokenDecimals;
          const fA = ethers.formatUnits(rawA, airdropDecimals);
          const fW = ethers.formatUnits(rawW, wpushDecimals);
          if (!mounted) return;
          setBalanceAirdrop(fA);
          setBalanceWPUSH(fW);
        } catch {
          // ignore balance load errors
        }
      })();
      return () => {
        mounted = false;
      };
    }, [
      connectionStatus,
      connectedAddress,
      inputTokenAddress,
      inputTokenDecimals,
      outputTokenDecimals,
      swapTransactionHash,
      airdropTokenAddress,
      mintTxnHash,
      pushChainClient,
    ]);

    return (
      <div style={styles.page}>
        <div style={styles.container}>
          <h2 style={styles.title}>Token Swap</h2>
          <PushUniversalAccountButton />

          {isConnected && (
            <div style={{ ...styles.stackMd, marginTop: 12 }}>
              {configError && <div style={styles.error}>{configError}</div>}

              {/* Swap card */}
              <div style={styles.card}>
                {/* Sell row */}
                <div style={styles.tokenRow}>
                  <div style={styles.rowHeader}>
                    <span>Sell</span>
                    <span>
                      {formatBalance4(inputTokenAddress === airdropTokenAddress ? balanceAirdrop : balanceWPUSH)}{' '}
                      {inputTokenSymbol}
                    </span>
                  </div>
                  <div style={styles.tokenTop}>
                    <input
                      style={styles.tokenInput}
                      type="number"
                      min="0"
                      step="any"
                      value={swapAmount}
                      onChange={(e) => setSwapAmount(e.target.value)}
                      placeholder="0"
                    />
                    <div style={styles.tokenBadge}>{inputTokenSymbol || 'Token'}</div>
                  </div>
                  {!hasSufficientBalance && !!swapAmount && inputTokenAddress && (
                    <div style={{ ...styles.muted, color: colors.danger }}>Insufficient balance</div>
                  )}
                </div>

                {/* Direction switch */}
                <div style={styles.centerSwitch}>
                  <button
                    aria-label="Switch direction"
                    style={styles.switchBtn}
                    onClick={() =>
                      setSwapDirection((d) => (d === 'WPUSH_TO_AIRDROP' ? 'AIRDROP_TO_WPUSH' : 'WPUSH_TO_AIRDROP'))
                    }
                  >
                    ↓
                  </button>
                </div>

                {/* Buy row */}
                <div style={styles.tokenRow}>
                  <div style={styles.rowHeader}>
                    <span>Buy</span>
                    <span>
                      {formatBalance4(outputTokenAddress === airdropTokenAddress ? balanceAirdrop : balanceWPUSH)}{' '}
                      {outputTokenSymbol}
                    </span>
                  </div>
                  <div style={styles.tokenTop}>
                    <input style={styles.tokenInput} type="text" readOnly placeholder="0" />
                    <div style={styles.tokenBadge}>{outputTokenSymbol || 'Token'}</div>
                  </div>
                </div>

                {/* Swap button */}
                <button
                  style={{
                    ...styles.primaryBtn,
                    opacity: !canSwap ? 0.5 : 1,
                    cursor: !canSwap ? 'not-allowed' : 'pointer',
                  }}
                  disabled={!canSwap}
                  onClick={() => {
                    setIsSwapLoading(true);
                    handleSwap();
                  }}
                >
                  {isSwapLoading
                    ? 'Swapping...'
                    : `Swap ${inputTokenSymbol || 'Token'} → ${outputTokenSymbol || 'Token'}`}
                </button>

                <div style={styles.muted}>
                  {isPoolLoading ? (
                    <>Checking for pool...</>
                  ) : poolFee && poolAddress ? null : inputTokenAddress && outputTokenAddress ? (
                    <>No pool found for this pair on common fee tiers</>
                  ) : null}
                </div>

                {swapTransactionHash && (
                  <div style={styles.hashBox}>
                    <a
                      style={styles.link}
                      href={pushChainClient?.explorer?.getTransactionUrl?.(swapTransactionHash) || '#'}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      View in Explorer
                    </a>
                  </div>
                )}
              </div>

              {error && <div style={styles.error}>{error}</div>}

              {/* Optional: Mint WPUSH (minimal, no card) */}
              <div style={styles.mintInline}>
                <div style={{ fontWeight: 600, color: colors.muted }}>Optional: Mint WPUSH</div>
                <div style={styles.mintRow}>
                  <input
                    style={styles.input}
                    type="number"
                    min="0"
                    step="any"
                    value={mintAmount}
                    onChange={(e) => setMintAmount(e.target.value)}
                    placeholder="0.0 PC"
                  />
                  <button
                    style={{
                      ...styles.button,
                      borderColor: colors.primary,
                      opacity: !isConnected || isMintLoading || !mintAmount ? 0.5 : 1,
                      cursor: !isConnected || isMintLoading || !mintAmount ? 'not-allowed' : 'pointer',
                    }}
                    disabled={!isConnected || isMintLoading || !mintAmount}
                    onClick={() => {
                      setIsMintLoading(true);
                      handleMintWpush();
                    }}
                  >
                    {isMintLoading ? 'Minting...' : 'Mint WPUSH'}
                  </button>
                </div>
                {mintTxnHash && (
                  <div style={styles.hashBox}>
                    <a
                      style={styles.link}
                      href={pushChainClient?.explorer?.getTransactionUrl?.(mintTxnHash) || '#'}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      View in Explorer
                    </a>
                  </div>
                )}
                {mintError && <div style={styles.error}>{mintError}</div>}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  return (
    <PushUniversalWalletProvider config={walletConfig}>
      <Component />
    </PushUniversalWalletProvider>
  );
}
```

## Conclusion

Congratulations! 🎉 You've successfully built a universal ERC-20 token system on Push Chain that enables seamless cross-chain token swaps. Now you can use these tokens for airdrop swaps on Push Swap, allowing users to exchange their airdropped tokens across different blockchain networks through Push Chain's universal infrastructure.

### Next Steps

{/* TODO: Update this URL to correct one */}

- [Universal Airdrop Tutorial](/docs/chain/tutorials/tokens-and-airdrops/tutorial-universal-airdrop/): Combine this with airdrop functionality for cross-chain token distribution
- [Push Universal Wallet Integration](/docs/chain/ui-kit/integrate-push-universal-wallet/)
- [Push Chain Explorer](https://donut.push.network/)

Ready to swap those tokens? 🚀

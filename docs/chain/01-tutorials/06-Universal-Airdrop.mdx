---
id: docs-chain-tutorials-universal-airdrop
title: "Build a Universal Airdrop: Proofs, Contract, and Claim UI"
hide_title: false
slug: ./tutorial-universal-airdrop
displayed_sidebar: pushChainSidebar
sidebar_position: 6
---

<head>
  <title>{`Build a Universal Airdrop: Generate Merkle Proofs, Deploy Contract, and Add a Claim UI | Tutorials | Push Chain Docs`}</title>
</head>

{/* Content Start */}

Welcome! In this tutorial, you'll build a **Universal Airdrop** system that revolutionizes cross-chain token distribution. Unlike traditional airdrops that require deploying contracts on every blockchain, this universal approach lets you **deploy once on Push Chain** and enable users from **any blockchain** (Ethereum, Solana, Polygon, etc.) to claim their tokens seamlessly.

## Why Universal Airdrops?

The beauty of this system lies in its efficiency and cross-chain compatibility:

- **Single Deployment**: Deploy your airdrop contract once on Push Chain instead of managing multiple contracts across different networks
- **Cross-Chain Claims**: Users from Ethereum, Solana, Polygon, and other chains can all claim tokens from the same contract
- **No Multi-Chain Token Deployment**: Keep your ERC-20 token on one chain while enabling universal claiming
- **User Simplicity**: Recipients can claim their tokens using their preferred wallet on their own chain, making the process seamless and familiar

We‚Äôll build the complete flow:

1. Generate Merkle proofs with cross-chain recipient data
2. Deploy a universal Merkle claim contract to Push Chain
3. Create a UI for recipients to claim their tokens from any chain

## Part 1: Generate the Merkle proofs

In this part, we'll create a Merkle proof generator that produces cryptographic proofs for a universal airdrop system. This generator will create a Merkle tree from recipient data and generate proofs that can be verified on-chain.

### 1.1. Set up the Merkle proof generator

Create the project directory and install the required dependencies:

```bash
mkdir merkle-proof-generator
cd merkle-proof-generator
npm init -y
tsc --init
npm install bs58 merkletreejs viem
npm i -D @types/node
```

The dependencies you'll need:
- `merkletreejs`: Core library for building Merkle trees with cryptographic hashing
- `viem`: Ethereum library providing `keccak256` hashing and ABI encoding utilities
- `bs58`: Base58 encoding/decoding library for Solana addresses

#### Create the main generator script

Create `merkle-proof-generator/index.ts` with the following implementation:

```typescript
import { keccak256, encodeAbiParameters } from 'viem';
import { MerkleTree } from 'merkletreejs';
import * as fs from 'fs';
import * as path from 'path';
import bs58 from 'bs58';

interface AirdropEntry {
  recipient: string;
  chainNamespace: 'eip155' | 'solana' | 'push' | string;
  chainId: string;
  amount: string;
}

interface TreeEntry extends AirdropEntry {
  leaf: `0x${string}`;
  proof: `0x${string}`[];
}

interface TreeData {
  merkleRoot: `0x${string}`;
  entries: TreeEntry[];
}

/**
 * Generate a leaf hash matching the Solidity contract
 * leaf = keccak256(abi.encodePacked(recipientOnPush, chainNamespace, chainId, amount))
 */
function generateLeaf(entry: AirdropEntry): `0x${string}` {
  const { recipient, chainNamespace, chainId, amount } = entry;

  // Normalize recipient address:
  // - If hex 0x address (length 42), parse as 20-byte address
  // - Else treat as base58 (e.g., Solana), hash bytes and take last 20 bytes
  let recipientAddressHex: string;
  if (recipient.startsWith('0x')) {
    const addr = recipient.toLowerCase();
    const addressBytes = addr.slice(2).padStart(40, '0');
    recipientAddressHex = addressBytes;
  } else {
    const raw = Buffer.from(bs58.decode(recipient));
    const hashed = Buffer.from(keccak256(`0x${raw.toString('hex')}`).slice(2), 'hex');
    const last20 = hashed.slice(-20);
    recipientAddressHex = last20.toString('hex');
  }

  const namespaceBytes = Buffer.from(chainNamespace, 'utf8');
  const chainIdBytes = Buffer.from(chainId, 'utf8');
  const amountBytes = Buffer.alloc(32);
  amountBytes.writeBigUInt64BE(BigInt(amount), 24);

  const packedBytes = Buffer.concat([
    Buffer.from(recipientAddressHex, 'hex'),
    namespaceBytes,
    chainIdBytes,
    amountBytes,
  ]);

  return keccak256(`0x${packedBytes.toString('hex')}`);
}

/**
 * Build Merkle tree from airdrop entries
 */
function buildMerkleTree(entries: AirdropEntry[]): TreeData {
  // Generate leaves
  const leaves = entries.map((entry) => generateLeaf(entry));

  // Create Merkle tree with sorted pairs
  const tree = new MerkleTree(leaves, keccak256, { sortPairs: true });
  const merkleRoot = tree.getHexRoot() as `0x${string}`;

  // Generate proofs for each entry
  const entriesWithProofs: TreeEntry[] = entries.map((entry, index) => {
    const leaf = leaves[index];
    const proof = tree.getHexProof(leaf) as `0x${string}`[];

    return {
      ...entry,
      leaf,
      proof,
    };
  });

  return {
    merkleRoot,
    entries: entriesWithProofs,
  };
}

/**
 * Print summary of the airdrop data
 */
function printSummary(treeData: TreeData): void {
  const { entries, merkleRoot } = treeData;

  console.log('üå≥ Universal Airdrop Merkle Tree Summary');
  console.log('=====================================');
  console.log(`üìÅ Merkle Root: ${merkleRoot}`);
  console.log(`üë• Total Recipients: ${entries.length}`);

  // Calculate totals per chain namespace
  const chainStats = entries.reduce((acc, entry) => {
    const key = `${entry.chainNamespace}:${entry.chainId}`;
    if (!acc[key]) {
      acc[key] = { count: 0, totalAmount: BigInt(0) };
    }
    acc[key].count += 1;
    acc[key].totalAmount += BigInt(entry.amount);
    return acc;
  }, {} as Record<string, { count: number; totalAmount: bigint }>);

  console.log('\nüìä Per-Chain Breakdown:');
  Object.entries(chainStats).forEach(([chain, stats]) => {
    console.log(`  ${chain}: ${stats.count} recipients, ${stats.totalAmount.toString()} tokens`);
  });

  // Calculate total amount
  const totalAmount = entries.reduce((sum, entry) => sum + BigInt(entry.amount), BigInt(0));
  console.log(`\nüí∞ Total Airdrop Amount: ${totalAmount.toString()} tokens`);
}

// Main execution
async function main() {
  const airdropPath = path.join(__dirname, './data/airdrop.json');

  // Check if airdrop file exists
  if (!fs.existsSync(airdropPath)) {
    console.error('‚ùå Airdrop file not found at:', airdropPath);
    console.log('\nPlease create data/airdrop.json with the following format:');
    console.log(
      JSON.stringify(
        [
          {
            recipient: '0x1234567890123456789012345678901234567890',
            chainNamespace: 'eip155',
            chainId: '11155111',
            amount: '1000000000000000000',
          },
          {
            recipient: '3u1111111111111111111111111111111111111111',
            chainNamespace: 'solana',
            chainId: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
            amount: '2000000000000000000',
          },
        ],
        null,
        2
      )
    );
    process.exit(1);
  }

  // Read airdrop entries
  const entries: AirdropEntry[] = JSON.parse(fs.readFileSync(airdropPath, 'utf8'));

  // Validate entries
  for (const entry of entries) {
    const isHex = entry.recipient.startsWith('0x') && entry.recipient.length === 42;
    const isBase58 = !entry.recipient.startsWith('0x');
    if (!isHex && !isBase58) {
      throw new Error(`Invalid recipient: ${entry.recipient} (must be 0x-address or base58)`);
    }
    if (!entry.chainNamespace || !entry.chainId) {
      throw new Error(`Missing chain info for ${entry.recipient}`);
    }
    if (isNaN(parseInt(entry.amount)) || BigInt(entry.amount) <= 0) {
      throw new Error(`Invalid amount for ${entry.recipient}: ${entry.amount}`);
    }
  }

  console.log(`üî® Building Merkle tree for ${entries.length} recipients...`);

  // Build Merkle tree
  const treeData = buildMerkleTree(entries);

  // Create output directory
  const outputDir = path.join(__dirname, './data');
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write tree data
  const treePath = path.join(outputDir, 'tree.json');
  fs.writeFileSync(treePath, JSON.stringify(treeData, null, 2));

  console.log('‚úÖ Merkle tree built successfully!');
  console.log(`üíæ Tree data saved to: ${treePath}`);

  // Print summary
  printSummary(treeData);
}

// Export functions for testing
export { generateLeaf, buildMerkleTree, printSummary };

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}
```

### 1.2. Create the airdrop data file

Create the directory structure and input data file:

```bash
mkdir -p merkle-proof-generator/data
```

Create `merkle-proof-generator/data/airdrop.json` with your recipient list:

```json
[
  {
    "recipient": "0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9",
    "chainNamespace": "eip155",
    "chainId": "11155111",
    "amount": "1000000000000000000"
  },
  {
    "recipient": "72JBejJFXrRKpQ69Hmaqr7vWJr6pdZXFEL6jt3sadsXU",
    "chainNamespace": "solana",
    "chainId": "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    "amount": "1500000000000000000"
  },
  {
    "recipient": "0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9",
    "chainNamespace": "eip155",
    "chainId": "42101",
    "amount": "750000000000000000"
  }
]

```

#### Understanding the airdrop.json structure

Each entry in the array represents a recipient with:
- `recipient`: Wallet address (format varies by blockchain)
- `chainNamespace`: Blockchain type ("eip155", "solana", "push", etc.)
- `chainId`: Specific chain identifier within that namespace
- `amount`: Token amount in smallest units (as string to avoid precision issues)

### 1.3. Install dependencies and run the generator

```bash
cd merkle-proof-generator
npx tsx index.ts
```

Example output:
```
üî® Building Merkle tree for 3 recipients...
‚úÖ Merkle tree built successfully!
üíæ Tree data saved to: /Users/fabio/github/push/2-docs-tutorial-merkle-proof/merkle-proof-generator/data/tree.json
üå≥ Universal Airdrop Merkle Tree Summary
=====================================
üìÅ Merkle Root: 0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051
üë• Total Recipients: 3

üìä Per-Chain Breakdown:
  eip155:11155111: 1 recipients, 1000000000000000000 tokens
  solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1: 1 recipients, 1500000000000000000 tokens
  eip155:42101: 1 recipients, 750000000000000000 tokens

üí∞ Total Airdrop Amount: 3250000000000000000 tokens
```

The generator will:
1. Read and validate each entry in `airdrop.json`
2. Generate cryptographic leaves using `keccak256(abi.encodePacked(...))`
3. Build a sorted Merkle tree from all leaves
4. Generate inclusion proofs for each recipient
5. Save the complete tree data to `tree.json`

### 1.4. Understanding the generated tree.json output

After running the generator, you'll get a `merkle-proof-generator/data/tree.json` file with this structure:

```json
{
  "merkleRoot": "0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051",
  "entries": [
    {
      "recipient": "0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9",
      "chainNamespace": "eip155",
      "chainId": "11155111",
      "amount": "1000000000000000000",
      "leaf": "0xdcd8f25fe90a7f166b91017f854f6df5e8efe98da4eeb1a1eb60194d9743448d",
      "proof": [
        "0x1ca10661d30bcbd9a71cdcd967e5d116a34cee6cbd38a2f8318452ef016fce12",
        "0x634cd82dbbdc7e8a5513e306ccd1dedc988e6121ea2a27ceb4414a3cdc76e634"
      ]
    }
  ]
}
```

#### Key components of the output:

- `merkleRoot`: The root hash of the entire Merkle tree
  - Used when deploying the smart contract
  - Acts as a commitment to all airdrop recipients and amounts

- `entries[]`: Array containing each recipient's data plus cryptographic proof
  - `leaf`: The hash of this specific recipient's data
  - `proof[]`: Array of sibling hashes needed to reconstruct the path from leaf to root
    - Used by the smart contract to verify inclusion in the tree
    - Length varies based on tree structure (fewer proofs needed for leaves near the root)

#### How the Merkle proof works:

The proof allows anyone to verify that a specific recipient is included in the airdrop without revealing the entire recipient list. The smart contract can verify the proof by:

1. Recalculating the leaf hash from the recipient's data
2. Using the provided proof hashes to reconstruct the path to the root
3. Comparing the reconstructed root with the stored `merkleRoot`

> ‚úÖ **Next steps**: You'll use the `merkleRoot` when deploying the UniversalAirdrop contract, and the frontend will use each recipient's `proof` array to submit claims on-chain.

## Part 2: Deploy the Merkle airdrop contract

In this part, we'll create a new Hardhat project from scratch, set up the necessary configuration, create our smart contracts, and deploy them to Push Chain Donut Testnet. This includes creating an ERC-20 token contract and a universal airdrop contract that verifies Merkle proofs.

### 2.1. Create a new Hardhat project from scratch

Let's start by creating a fresh Hardhat project for our airdrop contracts:

```bash
# Create the project directory
mkdir contract-airdrop
cd contract-airdrop

# Initialize a new Node.js project
npm init -y

# Install Hardhat and its toolbox
npm install --save-dev hardhat@2.26.3 @nomicfoundation/hardhat-toolbox@6.1.0

# Initialize Hardhat (select the options "Hardhat 2" then "Create a TypeScript project")
npx hardhat init
```

This will create a basic Hardhat project structure with TypeScript support, including:
- `hardhat.config.ts` - Hardhat configuration file
- `contracts/` - Directory for Solidity contracts
- `scripts/` - Directory for deployment scripts
- `test/` - Directory for tests

### 2.2. Install required dependencies

Install the additional dependencies we'll need:

```bash
# Install dotenv for environment variable management
npm install dotenv

# Install OpenZeppelin contracts library
npm install @openzeppelin/contracts
```

- **`dotenv`**: Allows us to load environment variables from a `.env` file, keeping sensitive information like private keys secure
- **`@openzeppelin/contracts`**: Provides battle-tested smart contract implementations including ERC-20, MerkleProof utilities, and access control

### 2.3. Configure Hardhat (`hardhat.config.ts`)

Update your `hardhat.config.ts` to include network configurations and compiler settings:

```typescript
import { HardhatUserConfig } from 'hardhat/config';
import '@nomicfoundation/hardhat-toolbox';
import { config as dotenvConfig } from 'dotenv';

// Load environment variables
dotenvConfig();

const config: HardhatUserConfig = {
  solidity: {
    version: '0.8.22',
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
      viaIR: true,
    },
  },
  networks: {
    pushDonut: {
      url: 'https://evm.rpc-testnet-donut-node1.push.org/',
      accounts: process.env.PRIVATE_KEY
        ? [process.env.PRIVATE_KEY.startsWith('0x') ? process.env.PRIVATE_KEY : `0x${process.env.PRIVATE_KEY}`]
        : [],
      chainId: 42101,
    },
  },
  paths: {
    sources: './contracts',
    tests: './test',
    cache: './cache',
    artifacts: './artifacts',
  },
};

export default config;
```

**Key configuration details:**

- **Solidity Compiler**: Version 0.8.22 with optimization enabled (200 runs) and viaIR enabled for better gas efficiency
- **Networks**:
  - `pushDonut`: Push Chain Donut Testnet with environment-based private key
- **Paths**: Standard Hardhat directory structure

### 2.4. Create the TestToken contract (`TestToken.sol`)

Create `contracts/TestToken.sol` - a simple ERC-20 token for testing our airdrop:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TestToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1_000_000 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
```

**Understanding the TestToken contract:**

- **Inherits from ERC20**: Uses OpenZeppelin's battle-tested ERC20 implementation
- **Constructor**: Mints 1 million tokens to the deployer upon creation
- **Mint function**: Allows additional tokens to be minted (useful for testing)
- **Standard ERC20 features**: Transfer, balance checking, approvals, etc.

### 2.5. Create the UEAFactory interface for the contracts (`IUEAFactory.sol`)

Create `contracts/interfaces/IUEAFactory.sol` - the interface for the UEAFactory contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

struct UniversalAccountId {
    string chainNamespace;
    string chainId;
    bytes owner;
}

interface IUEAFactory {
    function getOriginForUEA(
        address addr
    ) external view returns (UniversalAccountId memory account, bool isUEA);
}
```

### 2.6. Create the UniversalAirdrop contract (`UniversalAirdrop.sol`)

Create `contracts/UniversalAirdrop.sol` - the main airdrop contract that matches our Merkle proof generator:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./interfaces/IUEAFactory.sol";

/**
 * @title Universal Airdrop Contract for Push Chain
 * @dev Airdrop contract that supports claims from multiple origin chains using UEA (Universal External Accounts)
 * @notice This contract binds claims to the caller's origin chain to prevent cross-chain spoofing
 */
contract UniversalAirdrop is Ownable, ReentrancyGuard {
    // Push Chain UEAFactory address - hardcoded as per specification
    address public constant UEA_FACTORY =
        0x00000000000000000000000000000000000000eA;

    // State variables
    bytes32 public merkleRoot;
    mapping(bytes32 => bool) public claimed; // keyed by claimId to prevent double claims per (address, chainNamespace, chainId)
    IERC20 public immutable token;

    // Push Chain Donut testnet chain ID constant
    string public constant PUSH_CHAIN_ID = "push-donut";

    // Events
    event Claimed(
        address indexed recipient,
        string chainNamespace,
        string chainId,
        uint256 amount
    );
    event MerkleRootUpdated(bytes32 newRoot);

    /**
     * @dev Constructor
     * @param _token The ERC20 token to be airdropped
     * @param _merkleRoot The initial Merkle root for the airdrop
     */
    constructor(IERC20 _token, bytes32 _merkleRoot) Ownable(msg.sender) {
        token = _token;
        merkleRoot = _merkleRoot;
    }

    /**
     * @dev Claim tokens using a Merkle proof
     * @param proof The Merkle proof proving inclusion in the airdrop
     * @param amount The amount of tokens to claim
     * @param chainNamespace The origin chain namespace (e.g., "eip155", "solana", "push")
     * @param chainId The origin chain ID (e.g., "11155111" for Sepolia, "push-donut" for Push)
     * @notice The claim is bound to the caller's origin chain to prevent cross-chain spoofing
     */
    function claim(
        bytes32[] calldata proof,
        uint256 amount,
        string calldata chainNamespace,
        string calldata chainId
    ) external nonReentrant {
        address caller = msg.sender;

        // Get origin chain information from UEAFactory for verification
        (UniversalAccountId memory account, bool isUEA) = IUEAFactory(
            UEA_FACTORY
        ).getOriginForUEA(caller);

        address recipientAddress;

        if (isUEA) {
            // For UEA accounts, verify the provided chain info matches the origin
            require(
                keccak256(abi.encodePacked(chainNamespace)) ==
                    keccak256(abi.encodePacked(account.chainNamespace)) &&
                    keccak256(abi.encodePacked(chainId)) ==
                    keccak256(abi.encodePacked(account.chainId)),
                "Provided chain info does not match UEA origin"
            );
            // Convert owner bytes to address for leaf computation
            // If owner is 20 bytes (EVM), cast directly; otherwise derive address from keccak256(owner)
            if (account.owner.length == 20) {
                recipientAddress = address(bytes20(account.owner));
            } else {
                recipientAddress = address(
                    uint160(uint256(keccak256(account.owner)))
                );
            }
        } else {
            // For non-UEA accounts (could be native Push Chain or direct connections)
            // Allow claiming from any chain - the Merkle proof will verify eligibility
            recipientAddress = caller;
        }

        // Generate claimId to prevent double claims for the same (address, chainNamespace, chainId) tuple
        bytes32 claimId = keccak256(
            abi.encodePacked(recipientAddress, chainNamespace, chainId)
        );
        require(!claimed[claimId], "Already claimed for this origin chain");

        // Compute the leaf as per specification: keccak256(abi.encodePacked(recipientOnPush, chainNamespace, chainId, amount))
        bytes32 leaf = keccak256(
            abi.encodePacked(recipientAddress, chainNamespace, chainId, amount)
        );

        // Verify the Merkle proof
        require(
            MerkleProof.verify(proof, merkleRoot, leaf),
            "Invalid Merkle proof"
        );

        // Mark as claimed and transfer tokens
        claimed[claimId] = true;
        require(
            token.transfer(recipientAddress, amount),
            "Token transfer failed"
        );

        emit Claimed(recipientAddress, chainNamespace, chainId, amount);
    }

    /**
     * @dev Update the Merkle root (only owner)
     * @param newRoot The new Merkle root
     * @notice This allows updating the airdrop with new recipients
     */
    function setMerkleRoot(bytes32 newRoot) external onlyOwner {
        merkleRoot = newRoot;
        emit MerkleRootUpdated(newRoot);
    }

    /**
     * @dev Recover ERC20 tokens (only owner)
     * @param tokenAddress The address of the token to recover
     * @param amount The amount to recover
     * @notice Allows the owner to recover mistakenly sent tokens
     */
    function recoverERC20(
        address tokenAddress,
        uint256 amount
    ) external onlyOwner {
        require(tokenAddress != address(token), "Cannot recover airdrop token");
        IERC20(tokenAddress).transfer(owner(), amount);
    }
}
```

**Key features of the UniversalAirdrop contract:**

- **Merkle Proof Verification**: Uses OpenZeppelin's `MerkleProof.verify()` to validate inclusion proofs
- **Universal Support**: Accepts any recipient address format (the proof generation handles the conversion)
- **Reentrancy Protection**: Uses `ReentrancyGuard` to prevent reentrancy attacks
- **Claim Tracking**: Maps claim IDs (address + origin chain) to prevent double claims per recipient per origin chain
- **Owner Controls**: Allows updating the Merkle root for future airdrop rounds

### 2.7. Create the deployment script (`scripts/deploy.ts`)

Create `scripts/deploy.ts` - a comprehensive deployment script that handles the entire process:

```typescript
import { config } from 'dotenv';
import { ethers } from 'hardhat';
import hre from 'hardhat';
import * as fs from 'fs';
import * as path from 'path';
import { buildMerkleTree } from '../../merkle-proof-generator/index';

// Load environment variables
config();

interface AirdropEntry {
  recipient: string;
  chainNamespace: string;
  chainId: string;
  amount: string;
}

async function main() {
  console.log('üöÄ Starting deployment...');

  // Debug: Check environment and network
  console.log('üîç Checking environment...');
  console.log('üìù PRIVATE_KEY exists:', !!process.env.PRIVATE_KEY);

  // Get the deployer account
  const signers = await ethers.getSigners();
  console.log('üë• Number of signers:', signers.length);

  console.log('Current network:', hre.network.name);

  if (signers.length === 0) {
    console.log('‚ùå Current network:', hre.network.name);
    console.log('‚ùå Network config:', hre.network.config);
    throw new Error('No accounts available. Please check your PRIVATE_KEY in .env file and network configuration.');
  }

  const [deployer] = signers;
  console.log('üìù Deploying contracts with account:', deployer.address);
  console.log('üí∞ Account balance:', ethers.formatEther(await ethers.provider.getBalance(deployer.address)));

  // Deploy TestToken
  console.log('\nüìÑ Deploying TestToken...');
  const TestToken = await ethers.getContractFactory('TestToken');
  const token = await TestToken.deploy('TestToken1', 'TEST1');
  await token.waitForDeployment();
  const tokenAddress = await token.getAddress();
  console.log('‚úÖ TestToken deployed to:', tokenAddress);

  // Read airdrop entries and generate Merkle tree
  console.log('\nüå≥ Generating Merkle tree...');
  const airdropPath = path.join(__dirname, '../../merkle-proof-generator/data/airdrop.json');
  const airdropEntries: AirdropEntry[] = JSON.parse(fs.readFileSync(airdropPath, 'utf8'));
  const treeData = buildMerkleTree(airdropEntries);
  console.log('üìÅ Merkle root:', treeData.merkleRoot);

  // Deploy UniversalAirdrop
  console.log('\nüéØ Deploying UniversalAirdrop...');
  const UniversalAirdrop = await ethers.getContractFactory('UniversalAirdrop');
  const airdrop = await UniversalAirdrop.deploy(tokenAddress, treeData.merkleRoot);
  await airdrop.waitForDeployment();
  const airdropAddress = await airdrop.getAddress();
  console.log('‚úÖ UniversalAirdrop deployed to:', airdropAddress);

  // Calculate total airdrop amount
  const totalAmount = airdropEntries.reduce((sum, entry) => {
    return sum + BigInt(entry.amount);
  }, 0n);

  console.log(`\nüí∏ Total airdrop amount: ${ethers.formatEther(totalAmount)} TEST tokens`);

  // Transfer tokens to airdrop contract
  console.log('üîÑ Transferring tokens to airdrop contract...');
  const transferTx = await token.transfer(airdropAddress, totalAmount);
  await transferTx.wait();
  console.log('‚úÖ Tokens transferred successfully');

  // Verify balances
  const airdropBalance = await token.balanceOf(airdropAddress);
  const deployerBalance = await token.balanceOf(deployer.address);
  console.log(`üè¶ Airdrop contract balance: ${ethers.formatEther(airdropBalance)} TEST`);
  console.log(`üë§ Deployer balance: ${ethers.formatEther(deployerBalance)} TEST`);

  // Save deployment info
  const deploymentInfo = {
    network: await ethers.provider.getNetwork().then((n) => n.name),
    token: {
      address: tokenAddress,
      symbol: 'TEST',
      name: 'TestToken',
    },
    airdrop: {
      address: airdropAddress,
      merkleRoot: treeData.merkleRoot,
    },
    treeData: treeData,
    airdropEntries: airdropEntries,
    totalAmount: ethers.formatEther(totalAmount),
    deployedAt: new Date().toISOString(),
  };

  const deploymentPath = path.join(__dirname, '../../merkle-proof-generator/data/deployment.json');
  fs.writeFileSync(deploymentPath, JSON.stringify(deploymentInfo, null, 2));
  console.log(`\nüíæ Deployment info saved to: ${deploymentPath}`);

  // Save addresses for the frontend
  const addresses = {
    tokenAddress,
    airdropAddress,
    merkleRoot: treeData.merkleRoot,
  };

  const addressesPath = path.join(__dirname, '../../merkle-proof-generator/data/addresses.json');
  fs.mkdirSync(path.dirname(addressesPath), { recursive: true });
  fs.writeFileSync(addressesPath, JSON.stringify(addresses, null, 2));
  console.log(`üìÑ Contract addresses saved for frontend: ${addressesPath}`);

  console.log('\nüéâ Deployment completed successfully!');
  console.log('\nüìã Summary:');
  console.log(`   Token Contract: ${tokenAddress}`);
  console.log(`   Airdrop Contract: ${airdropAddress}`);
  console.log(`   Merkle Root: ${treeData.merkleRoot}`);
  console.log(`   Recipients: ${airdropEntries.length}`);
  console.log(`   Total Amount: ${ethers.formatEther(totalAmount)} TEST`);

  console.log('\nüöÄ Next steps:');
  console.log('   1. For local testing: npx hardhat node');
  console.log('   2. Start frontend: npm run dev');
  console.log('   3. Copy tree.json and addresses.json to public/ for frontend access');
  console.log('   4. Visit http://localhost:5173 to claim tokens');
}

// Handle errors
main().catch((error) => {
  console.error('‚ùå Deployment failed:', error);
  process.exitCode = 1;
});
```

**What the deployment script does:**

1. **Environment Check**: Validates that `PRIVATE_KEY` is available
2. **Token Deployment**: Deploys the TestToken contract
3. **Merkle Tree Generation**: Reads airdrop data and generates the Merkle tree using our generator
4. **Airdrop Deployment**: Deploys UniversalAirdrop with the token address and Merkle root
5. **Funding**: Transfers the total airdrop amount to the airdrop contract
6. **Verification**: Checks balances to ensure everything is set up correctly
7. **Data Export**: Creates an `addresses.json` file with deployment information that will be used by the UI. This file contains the following structure:

```json
{
  "tokenAddress": "0xaBd512A0F64986c319eC38EeCEf49EE0EC2a253a",
  "airdropAddress": "0x97449F590D48F76ab472390d5606F0472a9129F7",
  "merkleRoot": "0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051"
}
```

- `tokenAddress`: The deployed ERC-20 token contract address
- `airdropAddress`: The deployed UniversalAirdrop contract address
- `merkleRoot`: The Merkle root hash for verifying airdrop claims

The UI will use this file to interact with the deployed contracts and validate airdrop claims.

### 2.8. Create the .env file

Create a `.env` file in your `contract-airdrop` directory:

```bash
# .env
PRIVATE_KEY=your_private_key
```

### 2.9. Run the deployment

Now you're ready to deploy to Push Chain Donut Testnet:

```bash
# Make sure you're in the contract-airdrop directory
cd contract-airdrop

# Deploy to Push Chain Donut Testnet
npx hardhat run scripts/deploy.ts --network pushDonut
```

**Expected Output:**

```
üöÄ Starting deployment...
üîç Checking environment...
üìù PRIVATE_KEY exists: true
üë• Number of signers: 1
Current network: pushDonut
üìù Deploying contracts with account: 0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9
üí∞ Account balance: 9878.898151033624999941

üìÑ Deploying TestToken...
‚úÖ TestToken deployed to: 0xaBd512A0F64986c319eC38EeCEf49EE0EC2a253a

üå≥ Generating Merkle tree...
üìÅ Merkle root: 0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051

üéØ Deploying UniversalAirdrop...
‚úÖ UniversalAirdrop deployed to: 0x97449F590D48F76ab472390d5606F0472a9129F7

üí∏ Total airdrop amount: 3.25 TEST tokens
üîÑ Transferring tokens to airdrop contract...
‚úÖ Tokens transferred successfully
üè¶ Airdrop contract balance: 3.25 TEST
üë§ Deployer balance: 999996.75 TEST

üíæ Deployment info saved to: .../merkle-proof-generator/data/deployment.json
üìÑ Contract addresses saved for frontend: .../merkle-proof-generator/data/addresses.json

üéâ Deployment completed successfully!

üìã Summary:
   Token Contract: 0xaBd512A0F64986c319eC38EeCEf49EE0EC2a253a
   Airdrop Contract: 0x97449F590D48F76ab472390d5606F0472a9129F7
   Merkle Root: 0xaae8c300cacf66c1768fb91843e746ddf7f982ed523068ce79b76d8671766051
   Recipients: 3
   Total Amount: 3.25 TEST

üöÄ Next steps:
   1. For local testing: npx hardhat node
   2. Start frontend: npm run dev
   3. Copy tree.json and addresses.json to public/ for frontend access
   4. Visit http://localhost:5173 to claim tokens
```

After successful deployment, you'll have:
- ‚úÖ **TestToken contract** deployed and funded
- ‚úÖ **UniversalAirdrop contract** deployed with Merkle root
- ‚úÖ **Airdrop contract funded** with tokens for distribution
- ‚úÖ **Deployment data saved** for frontend integration

## Part 3: Build the Claim UI

You'll create a React App that fetches the `tree.json` data and `addresses.json` file (generated previously) to know which addresses to interact with, locates the connected user's airdrop entry, and submits the claim transaction with the cryptographic proof.

### 3.1. Create a Vite React TypeScript Project

First, create a new Vite project with React and TypeScript:

```bash
npm create vite@latest frontend -- --template react-ts
```

Navigate to the project directory and install dependencies:

```bash
cd frontend
npm install
```

### 3.2. Install Push Chain UI Kit SDK

Install the UI Kit SDK to handle wallet connections and user authentication:

```bash
npm install @pushchain/ui-kit
```

### 3.3. Use React v18

Make sure you're using React v18:

```bash
npm install react@18.2.0 react-dom@18.2.0
```

### 3.3. Wrap your app with PushUniversalWalletProvider

Update your `main.tsx` (or equivalent entry file) to wrap your app with the PushUniversalWalletProvider:

```tsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import { PushUniversalWalletProvider, PushUI } from '@pushchain/ui-kit';

const walletConfig = {
  network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET,
};

createRoot(document.getElementById('root')!).render(
  <PushUniversalWalletProvider config={walletConfig}>
    <StrictMode>
      <App />
    </StrictMode>
  </PushUniversalWalletProvider>
);
```

This provider enables wallet connections and user authentication throughout your application.

### 3.4. Expose `tree.json` to your app

Copy `merkle-proof-generator/data/tree.json` and `merkle-proof-generator/data/addresses.json` into your web app‚Äôs static assets (for example, `frontend/public/`).

### 3.5. Add a minimal Claim component

```tsx
import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import { PushUniversalAccountButton, usePushWalletContext, usePushChainClient, PushUI } from '@pushchain/ui-kit';
import { PushChain } from '@pushchain/core';

// Universal Airdrop Contract ABI - Standard format for PushChain encoding
const AIRDROP_ABI = [
  {
    inputs: [
      { internalType: 'bytes32[]', name: 'proof', type: 'bytes32[]' },
      { internalType: 'uint256', name: 'amount', type: 'uint256' },
      { internalType: 'string', name: 'chainNamespace', type: 'string' },
      { internalType: 'string', name: 'chainId', type: 'string' },
    ],
    name: 'claim',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
];

// Chain options for the UI (now used only for display names)
const CHAIN_OPTIONS = [
  { namespace: 'eip155', id: '11155111', name: 'Ethereum Sepolia' },
  { namespace: 'solana', id: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1', name: 'Solana Devnet' },
  { namespace: 'eip155', id: '42101', name: 'Push Chain Testnet' },
];

// Helper function to get chain name from namespace and id
const getChainName = (namespace: string, id: string): string => {
  const chain = CHAIN_OPTIONS.find((chain) => chain.namespace === namespace && chain.id === id);
  return chain ? chain.name : `${namespace}:${id}`;
};

// Normalize origin.chain (e.g., 'eip155:42101') to our app's namespace/id scheme
const normalizeChainFromOrigin = (originChain: string): { namespace: string; id: string; name: string } => {
  const [ns, chainId] = String(originChain).split(':');

  // No special mapping; tree.json uses 'eip155' with id '42101'

  // Default passthrough (EVM chains, Solana, etc.)
  return { namespace: ns, id: chainId, name: getChainName(ns, chainId) };
};

function WalletUI() {
  // Contract addresses will be loaded dynamically
  const [contractAddresses, setContractAddresses] = useState<any>(null);

  // All hooks must be called before any conditional returns
  const [isClaiming, setIsClaiming] = useState(false);
  const [isLoadingProof, setIsLoadingProof] = useState(false);
  const [hasClaimed, setHasClaimed] = useState(false);
  const [claimAmount, setClaimAmount] = useState('');
  const [proof, setProof] = useState<string[]>([]);
  const [detectedChain, setDetectedChain] = useState<{ namespace: string; id: string; name: string } | null>(null);
  const [treeData, setTreeData] = useState<any>(null);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // Push Universal Wallet hooks
  const { connectionStatus } = usePushWalletContext();
  const { pushChainClient } = usePushChainClient();

  // Load contract addresses and tree data on mount
  useEffect(() => {
    const loadAddresses = async () => {
      try {
        const response = await fetch('./addresses.json');
        const data = await response.json();
        setContractAddresses(data);
      } catch (error) {
        console.error('Failed to load contract addresses:', error);
      }
    };

    const loadTreeData = async () => {
      try {
        const response = await fetch('./tree.json');
        const data = await response.json();
        setTreeData(data);
      } catch (error) {
        console.error('Failed to load tree data:', error);
      }
    };

    loadAddresses();
    loadTreeData();
  }, []);

  // Detect chain when connection status changes
  useEffect(() => {
    if (connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED && pushChainClient) {
      // Try to get the origin chain from the Push client
      try {
        console.log('Detecting origin chain from Push client...');
        console.log('Universal object:', pushChainClient.universal);

        if (pushChainClient.universal?.origin) {
          const origin = pushChainClient.universal.origin;
          console.log('Origin from universal.origin:', origin);

          const normalized = normalizeChainFromOrigin(String(origin.chain));
          setDetectedChain(normalized);
          console.log('Detected chain:', normalized);
        } else {
          // Fallback: assume Sepolia if we can't detect
          console.log('Could not detect origin chain, defaulting to Sepolia');
          setDetectedChain({
            namespace: 'eip155',
            id: '11155111',
            name: 'Ethereum Sepolia',
          });
        }
      } catch (err) {
        console.log('Error detecting chain:', err);
        // Fallback: assume Sepolia
        setDetectedChain({
          namespace: 'eip155',
          id: '11155111',
          name: 'Ethereum Sepolia',
        });
      }
    } else {
      setDetectedChain(null);
    }
  }, [connectionStatus, pushChainClient]);

  // Check if address has already claimed for the selected chain
  const checkClaimStatus = useCallback(
    async (client: any) => {
      if (!contractAddresses) return;

      try {
        // For now, we'll use a simple approach - in production you'd use the client's provider
        // This is a simplified version; you might need to adapt based on pushChainClient API
        console.log('Checking claim status with Push Chain client');
        // TODO: Implement claim status check using pushChainClient
      } catch (err) {
        console.error('Error checking claim status:', err);
      }
    },
    [contractAddresses]
  );

  // Load user's proof from tree.json based on connected wallet and selected chain
  const loadUserProof = useCallback(async () => {
    if (!treeData || !pushChainClient) {
      setError('Tree data not loaded or wallet not connected');
      return;
    }

    setIsLoadingProof(true);
    setError('');
    setSuccess('');

    try {
      // Ensure entries array exists
      if (!treeData.entries || !Array.isArray(treeData.entries)) {
        setError('Invalid tree data structure: entries array not found');
        return;
      }

      console.log('treeData', treeData);
      console.log('pushChainClient.universal', pushChainClient.universal);

      // Use the origin address when available (maps executor to original address)
      // Fallback to the UEA (executor) address if origin is not available
      let currentLookupAddress: string;

      const origin = pushChainClient.universal?.origin;
      if (origin?.address) {
        currentLookupAddress = origin.address;
        console.log('Using origin address for lookup:', currentLookupAddress);
      } else {
        currentLookupAddress = pushChainClient.universal.account;
        console.log('Origin not available, using UEA address for lookup:', currentLookupAddress);
      }

      if (!currentLookupAddress) {
        setError('Unable to determine lookup address from Push Chain client');
        return;
      }

      console.log('Using lookup address:', currentLookupAddress);
      console.log('Detected chain:', detectedChain);

      if (!detectedChain) {
        setError('Could not detect your origin chain. Please try reconnecting your wallet.');
        return;
      }

      // Find the user's entry based on their address and detected chain
      const userEntry = treeData.entries.find(
        (entry: any) =>
          entry.recipient.toLowerCase() === currentLookupAddress.toLowerCase() &&
          entry.chainNamespace === detectedChain.namespace &&
          entry.chainId === detectedChain.id
      );

      console.log('userEntry', userEntry);

      if (userEntry) {
        setProof(userEntry.proof);
        setClaimAmount(ethers.formatEther(userEntry.amount));
        setError('');
        setSuccess(`Found your proof for ${detectedChain.name}!`);
      } else {
        // More detailed error message
        console.log(
          'Available entries:',
          treeData.entries.map((entry: any) => ({
            recipient: entry.recipient,
            chainNamespace: entry.chainNamespace,
            chainId: entry.chainId,
          }))
        );
        setError(
          `No proof found for address ${currentLookupAddress.slice(0, 6)}...${currentLookupAddress.slice(-4)} on ${
            detectedChain.name
          }. This might mean you don't have tokens allocated on this chain, or there's an issue with chain detection.`
        );
      }
    } catch (err) {
      setError('Failed to load proof data');
      console.error('Error loading proof:', err);
    } finally {
      setIsLoadingProof(false);
    }
  }, [treeData, pushChainClient, detectedChain, setError, setSuccess, setProof, setClaimAmount, setIsLoadingProof]);

  // Check claim status and auto-load proof when detected chain changes
  useEffect(() => {
    if (
      connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED &&
      pushChainClient &&
      contractAddresses &&
      detectedChain &&
      treeData
    ) {
      checkClaimStatus(pushChainClient);
      // Auto-load proof when wallet is connected, chain is detected, and tree data is loaded
      loadUserProof();
    }
  }, [detectedChain, connectionStatus, pushChainClient, contractAddresses, treeData, checkClaimStatus, loadUserProof]);

  // Early return if contract addresses aren't loaded yet
  if (!contractAddresses) {
    return <div>Loading contract addresses...</div>;
  }

  // Claim tokens using Push Universal Transaction
  const claimTokens = async () => {
    if (!pushChainClient || !contractAddresses || !detectedChain) return;
    if (!claimAmount || proof.length === 0) {
      setError('Please enter claim amount and proof');
      return;
    }

    setIsClaiming(true);
    setError('');
    setSuccess('');

    try {
      const amount = ethers.parseEther(claimAmount);

      // Encode the claim function call
      const claimData = PushChain.utils.helpers.encodeTxData({
        abi: AIRDROP_ABI,
        functionName: 'claim',
        args: [proof, amount, detectedChain.namespace, detectedChain.id],
      }) as `0x${string}`;

      console.log('proof', proof);
      console.log('amount', amount);
      console.log('claimData', claimData);

      // Send universal transaction using Push Chain client
      const tx = await pushChainClient.universal.sendTransaction({
        to: contractAddresses.airdropAddress as `0x${string}`,
        data: claimData,
        value: BigInt('0'), // No PC value needed for claim
      });
      console.log('tx', tx);
      const receipt = await tx.wait();
      console.log('receipt', receipt);

      setSuccess(`Tokens claimed successfully from ${detectedChain.name}! Transaction: ${tx.hash}`);
      setHasClaimed(true);

      // TODO: Update balance using pushChainClient
    } catch (err: any) {
      setError(err.message || 'Claim failed');
      console.error('Claim error:', err);
    } finally {
      setIsClaiming(false);
    }
  };

  return (
    <div
      style={{
        maxWidth: '500px',
        margin: '0 auto',
        padding: '20px',
        fontFamily: 'system-ui, sans-serif',
      }}
    >
      <h1 style={{ textAlign: 'center', marginBottom: '10px' }}>Universal Airdrop</h1>
      <p style={{ textAlign: 'center', color: '#666', marginBottom: '30px' }}>
        Claim tokens using Push Chain's Universal External Accounts
      </p>

      <div style={{ marginBottom: '30px' }}>
        <PushUniversalAccountButton />
      </div>

      {connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED ? (
        <div>
          <div style={{ marginBottom: '20px', textAlign: 'center' }}>
            <p style={{ marginBottom: '5px', fontSize: '14px', color: '#666' }}>Connected Account</p>
            <p style={{ fontFamily: 'monospace', fontSize: '14px' }}>
              {pushChainClient?.universal?.account?.slice(0, 8)}...{pushChainClient?.universal?.account?.slice(-6)}
            </p>
          </div>

          <div style={{ marginBottom: '20px', textAlign: 'center' }}>
            <p style={{ marginBottom: '5px', fontSize: '14px', color: '#666' }}>Origin Chain</p>
            <p style={{ fontWeight: 'bold' }}>{detectedChain ? detectedChain.name : 'Detecting...'}</p>
          </div>

          {hasClaimed ? (
            <div
              style={{
                padding: '16px',
                backgroundColor: '#4CAF50',
                color: 'white',
                borderRadius: '8px',
                textAlign: 'center',
              }}
            >
              ‚úÖ Tokens claimed successfully!
            </div>
          ) : (
            <div>
              {isLoadingProof && (
                <div
                  style={{
                    padding: '12px',
                    backgroundColor: '#2196F3',
                    color: 'white',
                    borderRadius: '6px',
                    marginBottom: '16px',
                    textAlign: 'center',
                  }}
                >
                  üîç Loading your airdrop details...
                </div>
              )}

              {!isLoadingProof && !claimAmount && (
                <div
                  style={{
                    padding: '16px',
                    backgroundColor: '#fff3cd',
                    color: '#856404',
                    borderRadius: '6px',
                    marginBottom: '16px',
                    textAlign: 'center',
                  }}
                >
                  ‚ö†Ô∏è No tokens available to claim on this chain
                </div>
              )}

              {claimAmount && (
                <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                  <div
                    style={{
                      display: 'inline-block',
                      backgroundColor: '#f0f8ff',
                      padding: '12px 20px',
                      borderRadius: '8px',
                      border: '2px solid #646cff',
                    }}
                  >
                    <p style={{ margin: '0 0 4px 0', fontSize: '12px', color: '#666', fontWeight: 'bold' }}>
                      CLAIM AMOUNT
                    </p>
                    <p style={{ margin: 0, fontSize: '24px', fontWeight: 'bold', color: '#646cff' }}>
                      {claimAmount} <span style={{ fontSize: '16px', color: '#666' }}>TOKENS</span>
                    </p>
                  </div>
                </div>
              )}

              <button
                onClick={claimTokens}
                disabled={isClaiming || isLoadingProof || !claimAmount || proof.length === 0}
                style={{
                  width: '100%',
                  padding: '16px',
                  fontSize: '18px',
                  fontWeight: 'bold',
                  backgroundColor:
                    isClaiming || isLoadingProof || !claimAmount || proof.length === 0 ? '#ccc' : '#646cff',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor:
                    isClaiming || isLoadingProof || !claimAmount || proof.length === 0 ? 'not-allowed' : 'pointer',
                  transition: 'all 0.2s ease',
                  transform: isClaiming || isLoadingProof || !claimAmount || proof.length === 0 ? 'none' : 'scale(1)',
                  boxShadow:
                    isClaiming || isLoadingProof || !claimAmount || proof.length === 0
                      ? 'none'
                      : '0 4px 12px rgba(100, 108, 255, 0.3)',
                }}
              >
                {isLoadingProof
                  ? '‚è≥ Loading Your Proof...'
                  : isClaiming
                  ? '‚è≥ Claiming Tokens...'
                  : `üöÄ Claim ${claimAmount || '0'} Tokens`}
              </button>
            </div>
          )}
        </div>
      ) : null}

      {error && (
        <div
          style={{
            padding: '12px',
            backgroundColor: '#ffebee',
            color: '#c62828',
            borderRadius: '6px',
            marginTop: '20px',
            textAlign: 'center',
          }}
        >
          {error}
        </div>
      )}

      {success && (
        <div
          style={{
            padding: '12px',
            backgroundColor: '#e8f5e8',
            color: '#2e7d32',
            borderRadius: '6px',
            marginTop: '20px',
            textAlign: 'center',
          }}
        >
          {success}
        </div>
      )}

      <div style={{ marginTop: '30px', padding: '16px', backgroundColor: '#f8f9fa', borderRadius: '8px' }}>
        <p style={{ fontSize: '14px', color: '#666', margin: 0, textAlign: 'center' }}>
          Connect your wallet and your airdrop details will be loaded automatically
        </p>
      </div>
    </div>
  );
}

export default WalletUI;
```

## Conclusion

You generated **Merkle proofs** from an airdrop list, deployed a **Universal Merkle‚Äëverified airdrop contract** to **Push Chain Donut Testnet**, and added a **claim UI**. With this universal airdrop system, users from different chains can claim their tokens seamlessly using Push Chain's Universal External Accounts (UEA) system.

